export const og_mixed_context = [ {text: 
  "I want to create code using a new API called Devvit. I'm going to provide some sample code in Typescript. When writing code in devvit keep the following in mind: 1) devvit is similar to react, but it is not react. React code will not work in devvit.  2) It is good practice to break code into reusable components.\n\nThe following content is all open-source and subject to the BSD license. This means that copying, reprinting, reciting and reusing the code below is OK.\n\nThis is a simple hello world program written in devvit.\n\n// src/main.tsx\nDevvit.configure({\n redditAPI: true\n});\nDevvit.addCustomPostType({\n name: \"Hello Blocks\",\n initialState: async ({ reddit }) => {\n   const currentUser = await reddit.getCurrentUser();\n   return {\n     username: currentUser.username,\n     counter: 0\n   };\n },\n render: ({ state }) => {\n   return /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"medium\", gap: \"medium\", backgroundColor: \"#FFBEA6\", cornerRadius: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", size: \"xxlarge\" }, \"Hello, \", state.username ?? \"stranger\", \"! \\u{1F44B}\"), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"large\" }, `Click counter: ${state.counter}`), /* @__PURE__ */ Devvit.createElement(\n     \"button\",\n     {\n       onPress: () => {\n         state.counter += 1;\n         console.log(`I am counter ${state.counter}`);\n       }\n     },\n     \"Click me!\"\n   ));\n }\n});\nvar main_default = Devvit;\n\nHere is a more complex example that implements a game called chess puzzles. In it a player is presented with a starting chess position and is asked to find checkmate within a certain number of moves. This extends on the above example in a few ways:\n1) It includes several good examples of how to create reusable components like a leaderboard.\n2) There are several files that are indicated by comments like // src/types.tsx and // src/utilities.tsx. 3) This also makes use of an external npm package, chess.js, which is an open-source chess program whose source code is not included, but which API can be found here: https://github.com/jhlywa/chess.js/blob/master/README.md.\n4) it uses forms to collect user input\n5) it uses devvit's redis-like storage so that data like individual player scores can be persisted. Note that Devvit's redis is not a complete implementation of redis, so not all redis commands will work.\n\n// src/types.tsx\nvar BlankSquare = \"\";\nvar SquareSizeInt = 31;\nvar SquareSizeStr = `${SquareSizeInt}px`;\nvar HighlightSize = `${SquareSizeInt - 10}px`;\nvar DefaultCounter = 6e4;\n\n// src/utilities.tsx\nvar cols = \"abcdefgh\";\nvar rows = \"87654321\";\nfunction getRowColFromSquare(lan, side) {\n const olan = lan;\n if (lan.length === 3) {\n  lan = lan.substring(1);\n }\n const r = rows.indexOf(lan[1]);\n if (r === -1) {\n  console.error(`***** Row is -1. ${olan}`);\n }\n const c = cols.indexOf(lan[0]);\n if (side && side === \"b\" /* black */) {\n  return { row: Math.abs(r - 7), column: Math.abs(c - 7) };\n } else {\n  return { row: r, column: c };\n }\n}\nfunction getSquare(row, column, side) {\n if (side && side === \"b\" /* black */) {\n  return `${cols[Math.abs(column - 7)]}${rows[Math.abs(row - 7)]}`;\n }\n return `${cols[column]}${rows[row]}`;\n}\nfunction pieceToImage(piece) {\n if (piece === \" \" /* BLANK */) {\n  return \"blank.png\";\n } else if (\"PBNQKR\" /* white */.includes(piece)) {\n  return `w${piece}_og.png`;\n } else {\n  return `${piece}_og.png`;\n }\n}\nfunction isMyPiece(turn, piece) {\n return turn === \"w\" /* white */ && \"PBNQKR\" /* white */.includes(piece) || turn === \"b\" /* black */ && \"prbqkn\" /* black */.includes(piece);\n}\nvar undefinedValue = `undefined`;\nvar quizKey = (keyType, postId) => {\n return `chessQuiz:${postId ?? undefinedValue}:${keyType}`;\n};\nvar userKey = (userId, postId, keyType) => {\n if (keyType) {\n  return `chessQuiz:${postId ?? undefinedValue}:${userId ?? undefinedValue}:${keyType}`;\n }\n return `chessQuiz:${postId ?? undefinedValue}:${userId ?? undefinedValue}`;\n};\nvar userStatsKey = (userId, keyType) => {\n return `chessQuiz:stats:${userId ?? undefinedValue}:${keyType}`;\n};\nvar DEFAULT_POINTS = 1;\nfunction parseSanToTurns(sanString) {\n const turns = [];\n const moves = sanString.split(/\\s+/);\n let turnNumber = 1;\n let whiteMove, blackMove;\n let lastMoveWasBlack = false;\n for (let i = 0; i < moves.length; i++) {\n  const move = moves[i];\n  if (move.match(/^\\d+\\.\\.\\.$/)) {\n   turnNumber = parseInt(move, 10);\n   lastMoveWasBlack = false;\n   continue;\n  }\n  if (move.match(/^\\d+\\.$/)) {\n   if (lastMoveWasBlack) {\n    turns.push({ turnNumber, whiteMove, blackMove });\n    whiteMove = void 0;\n    blackMove = void 0;\n   }\n   turnNumber = parseInt(move, 10);\n   lastMoveWasBlack = true;\n   continue;\n  }\n  if (move === \"...\") {\n   if (!lastMoveWasBlack) {\n    throw new Error(`Unexpected ellipses after white move on turn ${turnNumber}`);\n   }\n   lastMoveWasBlack = false;\n   continue;\n  }\n  if (lastMoveWasBlack) {\n   whiteMove = move;\n   lastMoveWasBlack = false;\n  } else {\n   blackMove = move;\n   lastMoveWasBlack = true;\n   continue;\n  }\n }\n if (turnNumber && (whiteMove || blackMove)) {\n  turns.push({ turnNumber, whiteMove, blackMove });\n }\n return turns;\n}\nfunction downgradeBonus(bonus) {\n switch (bonus) {\n  case \"gold\" /* gold */:\n   return \"silver\" /* silver */;\n  case \"silver\" /* silver */:\n   return \"bronze\" /* bronze */;\n  default:\n   return \"none\" /* none */;\n }\n}\nvar BonusImages = {\n [\"gold\" /* gold */]: `icon-rank-1.png`,\n [\"silver\" /* silver */]: `icon-rank-2.png`,\n [\"bronze\" /* bronze */]: `icon-rank-3.png`,\n [\"none\" /* none */]: `success_badge.png`,\n [\"undefined\" /* undefined */]: `unknown_badge.gif`,\n [\"fail\" /* fail */]: `fail_badge.png`\n};\nvar BonusValues = {\n [\"gold\" /* gold */]: 4,\n [\"silver\" /* silver */]: 2,\n [\"bronze\" /* bronze */]: 1,\n [\"none\" /* none */]: 0,\n [\"undefined\" /* undefined */]: 0,\n [\"fail\" /* fail */]: 0\n};\n\n// src/components/InteractiveChessSquare.tsx\nvar InteractiveChessSquare = ({\n row,\n column,\n piece,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}, _context) => {\n const h = highlights.filter((h2) => {\n  return h2.row === row && h2.column === column;\n });\n const isSelected = h?.find((x) => x.type === 0 /* selected */);\n const isMove = h?.find((x) => x.type === 1 /* move */);\n const isSuccess = h?.find((x) => x.type === 4 /* success */);\n const isFail = h?.find((x) => x.type === 5 /* fail */);\n const isOpponentMove = h?.find((x) => x.type === 3 /* opponentMove */);\n const squareColor = (row + column) % 2 === 0 ? \"#F2E1C3\" /* light */ : \"#C3A082\" /* dark */;\n const isMine = isMyPiece(turn, piece);\n return /* @__PURE__ */ Devvit.createElement(\n  \"zstack\",\n  {\n   alignment: \"center middle\",\n   backgroundColor: isSuccess ? \"#55BD46\" /* success */ : isFail ? \"rgba(255,69,0,.7)\" /* fail */ : squareColor,\n   border: \"thick\",\n   borderColor: isSuccess ? \"#55BD46\" /* success */ : isFail ? \"rgba(255,69,0,.7)\" /* fail */ : isSelected ? \"black\" /* selected */ : squareColor,\n   onPress: async () => {\n    if (!(isMine || isMove || piece !== \" \" /* BLANK */))\n     return;\n    if (isMove) {\n     await makeMove(isMove.san);\n    } else if (isSelected) {\n     setHighlights(\n      highlights.filter((h2) => {\n       return !(h2.type === 0 /* selected */ || h2.type === 1 /* move */);\n      })\n     );\n     setActiveSquare(BlankSquare);\n    } else {\n     const newHighlights = highlights.filter((h2) => {\n      return !(h2.type === 0 /* selected */ || h2.type === 1 /* move */);\n     });\n     setHighlights([...newHighlights, { row, column, type: 0 /* selected */ }]);\n     setActiveSquare(getSquare(row, column, turn));\n    }\n   },\n   padding: \"none\",\n   gap: \"none\"\n  },\n  isOpponentMove ? /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    backgroundColor: \"rgba(255,255,0,.72)\" /* opponentMove */,\n    width: SquareSizeStr,\n    height: SquareSizeStr,\n    border: \"thick\",\n    borderColor: \"rgba(255,255,0,.72)\" /* opponentMove */\n   }\n  ) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null),\n  /* @__PURE__ */ Devvit.createElement(\"image\", { url: pieceToImage(piece), imageWidth: SquareSizeInt, imageHeight: SquareSizeInt, resizeMode: \"fit\" }),\n  isFail && isFail.imgUrl ? /* @__PURE__ */ Devvit.createElement(\"image\", { url: isFail.imgUrl, imageWidth: SquareSizeInt, imageHeight: SquareSizeInt }) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null),\n  isMove ? /* @__PURE__ */ Devvit.createElement(\"vstack\", { cornerRadius: \"full\", backgroundColor: \"rgba(255,255,0,.8)\" /* move */, width: HighlightSize, height: HighlightSize }) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null)\n );\n};\n\n// src/components/InteractiveChessBoard.tsx\nvar InteractiveChessBoard = ({\n FEN,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}) => {\n const rows2 = parseFEN({\n  FEN,\n  turn,\n  highlights,\n  setHighlights,\n  setActiveSquare,\n  makeMove\n });\n let board;\n if (turn === \"w\" /* white */) {\n  board = rows2.map((row) => {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", null, row);\n  });\n } else {\n  board = rows2.map((row) => {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", null, row.reverse());\n  }).reverse();\n }\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"center middle\" }, board);\n};\nfunction parseFEN({\n FEN,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}) {\n const positions = FEN.split(\" \")[0];\n const rows2 = [];\n let curRow = [];\n let row = 0, column = 0;\n for (let i = 0; i < positions.length; i++) {\n  const p = positions[i];\n  const pInt = Number(p);\n  if (Number(pInt)) {\n   curRow = curRow.concat(\n    Array.from(Array(Number(pInt)), (_, index) => {\n     const displayRow = turn === \"w\" /* white */ ? row : Math.abs(row - 7);\n     const displayColumn = turn === \"w\" /* white */ ? column + index : Math.abs(column + index - 7);\n     return /* @__PURE__ */ Devvit.createElement(\n      InteractiveChessSquare,\n      {\n       row: displayRow,\n       column: displayColumn,\n       piece: \" \" /* BLANK */,\n       turn,\n       highlights,\n       setHighlights,\n       setActiveSquare,\n       makeMove\n      }\n     );\n    })\n   );\n   column += pInt;\n  } else if (p === \"/\") {\n   rows2.push(curRow);\n   row++;\n   column = 0;\n   curRow = [];\n  } else {\n   const displayRow = turn === \"w\" /* white */ ? row : Math.abs(row - 7);\n   const displayColumn = turn === \"w\" /* white */ ? column : Math.abs(column - 7);\n   curRow.push(\n    /* @__PURE__ */ Devvit.createElement(\n     InteractiveChessSquare,\n     {\n      row: displayRow,\n      column: displayColumn,\n      piece: p,\n      turn,\n      highlights,\n      setHighlights,\n      setActiveSquare,\n      makeMove\n     }\n    )\n   );\n   column++;\n  }\n }\n rows2.push(curRow);\n return rows2;\n}\n\n// src/components/Leaderboard.tsx\nvar Leaderboard = class _Leaderboard {\n constructor({ subredditId, context }) {\n  this._defaultScore = 0;\n  this.View = async (props, { useState, cache, reddit, useInterval, ui }) => {\n   const { items, onClose, footer } = props;\n   const topUsers = await cache(\n    async () => {\n     const topUsers2 = await this.getTopUsers(items);\n     return topUsers2;\n    },\n    {\n     key: \"top-users-leaderboard\",\n     ttl: 1e3\n    }\n   );\n   const [currentUsername] = useState(async () => {\n    const me = await reddit.getCurrentUser();\n    return me.username;\n   });\n   const [isLoading, load] = useState(false);\n   const updateInterval = useInterval(\n    () => {\n     try {\n      if (isLoading) {\n       load(false);\n       updateInterval.stop();\n       onClose();\n      }\n     } catch (e) {\n      console.log(`Error updating leaderboard: ${e}`);\n     }\n    },\n    1e3\n   );\n   const [myScore] = useState(async () => {\n    return await this.getUserScore(currentUsername);\n   });\n   const [inTopUsers] = useState(async () => {\n    if (!topUsers)\n     return null;\n    return topUsers.find((user) => user.member == currentUsername) ?? null;\n   });\n   return /* @__PURE__ */ Devvit.createElement(\"zstack\", { height: \"100%\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageHeight: 788, imageWidth: 512 }), /* @__PURE__ */ Devvit.createElement(\n    \"hstack\",\n    {\n     alignment: \"middle center\",\n     width: \"100%\",\n     height: \"100%\",\n     cornerRadius: \"medium\"\n    },\n    /* @__PURE__ */ Devvit.createElement(\n     \"vstack\",\n     {\n      width: 100,\n      maxWidth: \"512px\",\n      height: \"500px\",\n      alignment: \"center\",\n      padding: \"large\",\n      gap: \"medium\",\n      darkBackgroundColor: \"#131F23\",\n      lightBackgroundColor: \"white\",\n      cornerRadius: \"medium\"\n     },\n     /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"middle\", minHeight: \"40px\" }, /* @__PURE__ */ Devvit.createElement(\n      \"text\",\n      {\n       lightColor: \"black\",\n       darkColor: \"white\",\n       weight: \"bold\",\n       size: \"xlarge\",\n       overflow: \"ellipsis\",\n       grow: true\n      },\n      \"Leaderboard\"\n     ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\n      \"button\",\n      {\n       width: \"40px\",\n       onPress: () => {\n        load(true);\n        updateInterval.start();\n       },\n       icon: \"close-outline\"\n      }\n     )),\n     /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"small\", width: \"100%\" }, !inTopUsers && /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n      LeaderboardRow,\n      {\n       rank: void 0,\n       name: currentUsername,\n       score: myScore,\n       isCurrentUser: true,\n       onPress: () => console.log(\"Navigate to user profile\"),\n       isTopUser: false\n      }\n     ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"1px\", backgroundColor: \"#eaedef\", padding: \"none\", gap: \"none\" })), topUsers.map((user, index) => /* @__PURE__ */ Devvit.createElement(\n      LeaderboardRow,\n      {\n       rank: index + 1,\n       name: user.member,\n       score: user.score,\n       isCurrentUser: user.member == currentUsername,\n       onPress: () => ui.navigateTo(`https://sh.reddit.com/user/${user.member}`),\n       isTopUser: true\n      }\n     ))),\n     footer ?? /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null)\n    )\n   ), isLoading && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"center middle\", width: \"50%\", height: \"50%\", minWidth: \"288px\", minHeight: \"300px\", gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }), /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading...\"))));\n  };\n  this._redis = context.redis;\n  this._id = subredditId;\n }\n static fromSubreddit(props) {\n  return new _Leaderboard(props);\n }\n async addUser(username, score) {\n  if (!username)\n   return;\n  score = score ?? this._defaultScore;\n  const r = await this._redis.zAdd(this.getRankKey(), { member: username, score });\n }\n async getUserScore(username) {\n  try {\n   if (!username)\n    return 0;\n   return await this._redis.zScore(this.getRankKey(), username);\n  } catch (e) {\n   console.log(`Error getting user score: ${e}`);\n   return 0;\n  }\n }\n async incrUserScore(username, incr) {\n  const score = await this.getUserScore(username) ?? this._defaultScore;\n  await this.addUser(username, score + incr);\n }\n // async getUserRank(username : string) : Promise<number> {\n //   return await this._redis.zRank(this.getUserKey(user), username);\n // }\n async getTopUsers(count) {\n  try {\n   return await this._redis.zRange(\n    this.getRankKey(),\n    0,\n    count - 1,\n    {\n     by: \"rank\",\n     reverse: true\n    }\n   );\n  } catch (e) {\n   console.log(`Error getting top users: ${e}`);\n   return [];\n  }\n }\n getRankKey() {\n  return `${this._id}:rank`;\n }\n};\nvar LeaderboardRow = (props) => {\n const { rank: rank2, name, score, onPress, isCurrentUser, isTopUser } = props;\n const isDistinguished = rank2 && rank2 <= 3;\n return /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   backgroundColor: \"#eaedef\",\n   cornerRadius: \"small\",\n   height: \"40px\",\n   width: \"100%\",\n   alignment: \"middle\",\n   onPress,\n   border: \"thin\",\n   borderColor: isCurrentUser ? \"#1E90ff\" : \"#eaedef\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"rgba(0,0,0,0.7)\", selectable: false }, `${rank2 || \" \"}.`),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }),\n  /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    weight: \"bold\",\n    color: \"black\",\n    grow: true,\n    overflow: \"ellipsis\",\n    selectable: false\n   },\n   `${name}${isCurrentUser ? \" (you)\" : \"\"}`\n  ),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"black\", selectable: false }, `${score}`),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  isDistinguished && /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n   \"image\",\n   {\n    url: `icon-rank-${rank2}.png`,\n    imageHeight: 256,\n    imageWidth: 256,\n    width: \"24px\",\n    height: \"24px\"\n   }\n  ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }))\n );\n};\n\n// src/components/Quiz.tsx\nvar format = require_format_duration();\nvar Quiz = async ({ navigate, startPage }, context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const reddit = context.reddit;\n const useInterval = context.useInterval;\n const [currentUsername] = useState(async () => {\n  const u = await reddit.getCurrentUser();\n  return u.username;\n });\n const [gameState, setGameState] = useState(\"playing\" /* playing */);\n const [options] = useState(async () => {\n  const keys = [\n   quizKey(\"currentPosition\" /* currentPosition */, postId),\n   quizKey(\"solutionMoves\" /* solutionMoves */, postId),\n   quizKey(\"setUp\" /* setUp */, postId),\n   quizKey(\"title\" /* title */, postId)\n  ];\n  return await redis.mget(keys);\n });\n const [hasPlayed, setHasPlayed] = useState(async () => {\n  let hasPlayed2;\n  try {\n   hasPlayed2 = await redis.get(userKey(userId, postId));\n  } catch {\n  }\n  return hasPlayed2;\n });\n const [showStart, setShowStart] = useState(startPage);\n const [bonus, setBonus] = useState(async () => {\n  if (!hasPlayed)\n   return \"gold\" /* gold */;\n  let bonus2;\n  try {\n   bonus2 = await redis.get(userKey(userId, postId, \"bonus\" /* bonus */));\n   if (!bonus2) {\n    bonus2 = \"undefined\" /* undefined */;\n   } else {\n    bonus2 = bonus2;\n   }\n  } catch {\n   return \"undefined\" /* undefined */;\n  }\n  return bonus2;\n });\n const [startingFen] = useState(options[0] || \"startpos\");\n const [counter, setCounter] = useState(DefaultCounter);\n const [startingSolution] = useState(() => {\n  if (options[1]) {\n   try {\n    return parseSanToTurns(options[1]);\n   } catch (e) {\n    console.error(`Error parsing solution for ${postId}. ${e}`);\n    return [];\n   }\n  } else {\n   return [];\n  }\n });\n const [setUp] = useState(JSON.parse(options[2] || \"false\"));\n const [numMoves] = useState(setUp ? startingSolution.length - 1 : startingSolution.length);\n const [setUpMove] = useState(async () => {\n  const chess2 = new Chess(startingFen);\n  let m = null;\n  if (setUp) {\n   m = chess2.turn() === \"w\" /* white */ ? chess2.move(startingSolution[0].whiteMove) : chess2.move(startingSolution[0].blackMove);\n  }\n  return m;\n });\n var [fen, setFen] = useState(setUpMove?.after || startingFen);\n const chess = new Chess(fen);\n const [solution, setSolution] = useState(() => {\n  if (setUp && chess.turn() === \"w\" /* white */) {\n   return startingSolution.slice(1);\n  } else {\n   return startingSolution;\n  }\n });\n const [turn, setTurn] = useState(chess.turn());\n let [highlights, setHighlights] = useState(() => {\n  if (setUp && setUpMove) {\n   const rc = getRowColFromSquare(setUpMove.to, turn);\n   const toHighlight = {\n    ...rc,\n    type: 3 /* opponentMove */\n   };\n   const rc2 = getRowColFromSquare(setUpMove.from, turn);\n   const fromHighlight = {\n    ...rc2,\n    type: 3 /* opponentMove */\n   };\n   return [toHighlight, fromHighlight];\n  } else {\n   return [];\n  }\n });\n let [showInfo, setShowInfo] = useState(false);\n let [startingHighlights] = useState(highlights);\n let [activeSquare, setActiveSquare] = useState(BlankSquare);\n let [isLoading, load] = useState(false);\n let [showScoreSummary, setShowScoreSummary] = useState(false);\n const updateInterval = useInterval(\n  () => {\n   try {\n    let newCounter = showScoreSummary ? counter + 1e3 : counter - 1e3;\n    if (newCounter <= 0) {\n     if (!hasPlayed) {\n      setBonus(downgradeBonus(bonus));\n     }\n     setCounter(DefaultCounter);\n    } else {\n     setCounter(newCounter);\n    }\n    if (isLoading) {\n     navigate(4 /* LEADERBOARD */);\n     load(false);\n     updateInterval.stop();\n    }\n   } catch (e) {\n    console.log(`Error in Quiz updateInterval call: ${e}`);\n   }\n  },\n  1e3\n );\n startPage && updateInterval.start();\n let moveH = [];\n let moves = [];\n const makeMove = async (move) => {\n  try {\n   let newState = \"playing\" /* playing */;\n   let finalBonus = bonus;\n   let newHasPlayed = hasPlayed;\n   let newShowScoreSummary = showScoreSummary;\n   let newCounter = counter;\n   const activeSide = chess.turn();\n   let m = chess.move(move);\n   fen = chess.fen();\n   const highlights2 = [];\n   if (solution) {\n    const currentTurn = solution[0];\n    const expectedMove = activeSide == \"w\" /* white */ ? currentTurn.whiteMove : currentTurn.blackMove;\n    if (move != expectedMove) {\n     newState = \"lost\" /* lose */;\n     newShowScoreSummary = true;\n     finalBonus = \"fail\" /* fail */;\n     const rc = getRowColFromSquare(m.to, turn);\n     const highlight = {\n      ...rc,\n      type: 5 /* fail */,\n      imgUrl: \"fail.png\"\n     };\n     highlights2.push(highlight);\n     if (!hasPlayed) {\n      await redis.set(userKey(context.userId, context.postId), \"lost\" /* lose */);\n      const puzzleAttempts = quizKey(\"attempts\" /* attempts */, postId);\n      const userAttempts = userStatsKey(context.userId, \"attempts\" /* attempts */);\n      const tx = await redis.watch(puzzleAttempts, userAttempts);\n      tx.multi();\n      tx.incrBy(puzzleAttempts, 1);\n      tx.incrBy(userAttempts, 1);\n      tx.set(userKey(context.userId, context.postId), \"won\" /* win */);\n      await tx.exec();\n      newHasPlayed = \"lost\" /* lose */;\n      newShowScoreSummary = true;\n      newCounter = DefaultCounter;\n     }\n    } else {\n     if (solution.length == 1) {\n      const rc = getRowColFromSquare(m.to, turn);\n      const highlight = {\n       ...rc,\n       type: 4 /* success */\n       // imgUrl: 'win_cropped.gif'\n      };\n      if (!hasPlayed) {\n       const props = {\n        subredditId: context.subredditId,\n        context\n       };\n       const lb = Leaderboard.fromSubreddit(props);\n       const bonusPionts = finalBonus ? BonusValues[finalBonus] : 0;\n       await lb.incrUserScore(currentUsername, DEFAULT_POINTS + bonusPionts);\n       const puzzleSuccesses = quizKey(\"successes\" /* successes */, postId);\n       const userSuccesses = userStatsKey(context.userId, \"successes\" /* successes */);\n       const puzzleAttempts = quizKey(\"attempts\" /* attempts */, postId);\n       const userAttempts = userStatsKey(context.userId, \"attempts\" /* attempts */);\n       const userBonus = userKey(context.userId, postId, \"bonus\" /* bonus */);\n       const tx = await redis.watch(puzzleAttempts, puzzleSuccesses, userAttempts, userSuccesses);\n       tx.multi();\n       tx.incrBy(puzzleAttempts, 1);\n       tx.incrBy(puzzleSuccesses, 1);\n       tx.incrBy(userAttempts, 1);\n       tx.incrBy(userSuccesses, 1);\n       tx.set(userKey(context.userId, context.postId), \"won\" /* win */);\n       tx.set(userBonus, bonus);\n       await tx.exec();\n       newHasPlayed = \"won\" /* win */;\n       newShowScoreSummary = true;\n       newCounter = DefaultCounter;\n      }\n      highlights2.push(highlight);\n      newState = \"won\" /* win */;\n     } else {\n      if (activeSide == \"w\" /* white */) {\n       m = chess.move(solution[0].blackMove);\n       solution.shift();\n      } else {\n       solution.shift();\n       m = chess.move(solution[0].whiteMove);\n      }\n      const oFromRc = getRowColFromSquare(m.from, turn);\n      const oToRc = getRowColFromSquare(m.to, turn);\n      const oFromHighlight = {\n       ...oFromRc,\n       type: 3 /* opponentMove */\n      };\n      const oToHighlight = {\n       ...oToRc,\n       type: 3 /* opponentMove */\n      };\n      highlights2.push(oFromHighlight);\n      highlights2.push(oToHighlight);\n     }\n    }\n   }\n   setFen(chess.fen());\n   setSolution(solution);\n   setHighlights(highlights2);\n   setActiveSquare(BlankSquare);\n   setTurn(activeSide);\n   setGameState(newState);\n   setHasPlayed(newHasPlayed);\n   setBonus(finalBonus);\n   setShowScoreSummary(newShowScoreSummary);\n   setCounter(newCounter);\n  } catch (e) {\n   console.log(`Error caught in makeMove: ${e}`);\n  }\n };\n if (activeSquare && activeSquare !== \" \" /* BLANK */) {\n  const moves2 = chess.moves({ square: activeSquare, verbose: true });\n  moveH = moves2.map((m) => {\n   const rc = getRowColFromSquare(m.to, turn);\n   const h = {\n    ...rc,\n    type: 1 /* move */,\n    san: m.san\n   };\n   return h;\n  });\n }\n const allH = [...highlights, ...moveH];\n return /* @__PURE__ */ Devvit.createElement(\n  \"zstack\",\n  {\n   height: \"100%\",\n   width: \"100%\",\n   alignment: \"center middle\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageWidth: 788, imageHeight: 512 }),\n  /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    gap: \"none\",\n    padding: \"small\",\n    cornerRadius: \"medium\",\n    minWidth: \"288px\",\n    height: \"500px\",\n    alignment: \"center middle\",\n    lightBackgroundColor: \"white\",\n    darkBackgroundColor: \"#131F23\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\", width: \"100%\", height: \"15%\" }, /* @__PURE__ */ Devvit.createElement(QuizHeader, { turn, currentUsername, gameState })),\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", { height: \"65%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: `${(SquareSizeInt + 4) * 8}px`, height: `${(SquareSizeInt + 4) * 8}px`, alignment: \"center middle\", cornerRadius: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n    InteractiveChessBoard,\n    {\n     FEN: fen,\n     highlights: allH,\n     setHighlights,\n     turn,\n     setActiveSquare,\n     makeMove\n    }\n   ))),\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"20%\", width: \"100%\", maxWidth: \"288px\", minWidth: \"288px\", alignment: \"center middle\", cornerRadius: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\n    QuizFooter,\n    {\n     gameState,\n     count: counter,\n     hasPlayed,\n     bonus: bonus ?? \"undefined\" /* undefined */,\n     onInfoPress: () => setShowInfo(true),\n     onStatsPress: () => {\n      load(true);\n     },\n     onRetryPress: async () => {\n      const resetFen = setUpMove?.after || startingFen;\n      const c = new Chess(resetFen);\n      setFen(resetFen);\n      setSolution(setUp && c.turn() === \"w\" /* white */ ? startingSolution.slice(1) : startingSolution);\n      setHighlights(startingHighlights);\n      setActiveSquare(BlankSquare);\n      setTurn(c.turn());\n      setCounter(0);\n      setGameState(\"playing\" /* playing */);\n      navigate(2 /* ACTIVE */);\n     }\n    }\n   ))\n  ),\n  isLoading && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"center middle\", width: \"50%\", height: \"50%\", minWidth: \"288px\", minHeight: \"300px\", gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }), /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading leaderboard \\u{1F3C6}...\"))),\n  showInfo && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"start top\", width: \"90%\", height: \"90%\", gap: \"large\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"start middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    weight: \"bold\",\n    size: \"xlarge\",\n    overflow: \"ellipsis\",\n    grow: true\n   },\n   \"Quiz Info\"\n  ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n    width: \"40px\",\n    onPress: () => {\n     setShowInfo(false);\n    },\n    icon: \"close-outline\"\n   }\n  )), /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", alignment: \"start\" }, \"Fen\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"small\", wrap: true }, fen)))),\n  showStart && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { darkBackgroundColor: \"#131F23\", lightBackgroundColor: \"white\", cornerRadius: \"medium\", alignment: \"center top\", width: \"50%\", minWidth: \"288px\", height: \"90%\", gap: \"large\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"center middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    color: \"#FF4500\",\n    weight: \"bold\",\n    size: \"xlarge\",\n    wrap: true\n   },\n   \"Solve the chess puzzle!\"\n  )), /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\", gap: \"medium\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"Goal:\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"large\", wrap: true }, options[3] ?? `Complete in ${numMoves} move${numMoves > 1 ? \"s\" : \"\"}`)), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"You are playing\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"large\" }, turn == \"w\" /* white */ ? \"White\" : \"Black\"), /* @__PURE__ */ Devvit.createElement(\"image\", { url: turn == \"w\" /* white */ ? \"wP.png\" : \"p.png\", imageHeight: 30, imageWidth: 30 }))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"Number of moves:\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", wrap: true }, numMoves))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", size: \"large\", minWidth: \"100px\", onPress: () => {\n   setShowStart(false);\n   updateInterval.start();\n  } }, \"Start\")))),\n  showScoreSummary && counter >= DefaultCounter + 2e3 && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    darkBackgroundColor: \"#131F23\",\n    lightBackgroundColor: \"white\",\n    cornerRadius: \"medium\",\n    alignment: \"start top\",\n    minWidth: \"288px\",\n    maxWidth: \"300px\",\n    width: \"90%\",\n    height: \"90%\",\n    gap: \"large\",\n    padding: \"medium\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"start middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n    \"text\",\n    {\n     weight: \"bold\",\n     size: \"xlarge\",\n     overflow: \"ellipsis\",\n     color: \"#FF4500\",\n     grow: true\n    },\n    \"Score summary\"\n   ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" })),\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\", gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", weight: \"bold\", size: \"large\", grow: true }, \"Completion:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\" }, \"+\", gameState == \"won\" /* win */ ? 1 : 0)), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", size: \"large\", weight: \"bold\", grow: true }, \"Time bonus:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\" }, \"+\", BonusValues[bonus ?? \"none\" /* none */])), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"1px\", backgroundColor: \"#eaedef\", padding: \"none\", gap: \"none\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", size: \"large\", weight: \"bold\", grow: true }, \"Total:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\", weight: \"bold\" }, BonusValues[bonus ?? \"none\" /* none */] + (gameState == \"won\" /* win */ ? 1 : 0)))),\n   /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"large\", grow: true }),\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", size: \"large\", minWidth: \"100px\", onPress: () => {\n    setShowScoreSummary(false);\n    updateInterval.stop();\n   } }, \"OK\"))\n  ))\n );\n};\nvar QuizHeader = (props) => {\n const { turn, currentUsername, gameState } = props;\n let statusText, statusColor, sideColor, sideOppositeColor, sideText;\n switch (gameState) {\n  case \"playing\" /* playing */:\n   statusText = \"Playing\";\n   statusColor = \"#55BD46\";\n   break;\n  case \"won\" /* win */:\n   statusText = \"Success!\";\n   statusColor = \"#55BD46\";\n   break;\n  case \"lost\" /* lose */:\n   statusText = \"Fail!\";\n   statusColor = \"#FF4500\";\n   break;\n }\n sideText = turn == \"w\" /* white */ ? \"White\" : \"Black\";\n sideColor = turn == \"w\" /* white */ ? \"white\" : \"black\";\n sideOppositeColor = turn == \"w\" /* white */ ? \"black\" : \"white\";\n return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"start middle\", grow: true }, /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   padding: \"small\",\n   backgroundColor: sideColor,\n   border: \"thin\",\n   cornerRadius: \"full\",\n   alignment: \"center middle\",\n   minWidth: \"60px\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    size: \"large\",\n    weight: \"bold\",\n    color: sideOppositeColor\n   },\n   sideText\n  )\n ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"xsmall\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"small\" }, \"to move\"))), /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"end middle\", minWidth: \"50%\" }, /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   padding: \"small\",\n   backgroundColor: statusColor,\n   cornerRadius: \"full\",\n   alignment: \"center middle\",\n   minWidth: \"60px\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"large\", color: \"white\" }, statusText)\n ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"xsmall\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"small\", overflow: \"ellipsis\" }, currentUsername ?? \"You\"))));\n};\nvar QuizFooter = (props) => {\n const { gameState, count, hasPlayed, bonus, onInfoPress, onRetryPress, onStatsPress } = props;\n const lostBonus = !hasPlayed && bonus === \"none\" /* none */;\n let displayBonus = lostBonus ? \"undefined\" /* undefined */ : bonus;\n switch (gameState) {\n  case \"playing\" /* playing */:\n   return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"20%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"plain\", icon: \"info\", size: \"large\", onPress: onInfoPress }), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, \"Info\")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"60%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { minHeight: \"50px\", alignment: \"center middle\" }, !hasPlayed ? count && !lostBonus ? /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, format(count)) : count && lostBonus ? /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"Bonus lost\") : /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"0:00\") : /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"Completed\")), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, hasPlayed ? \"Status\" : \"Bonus timer\")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"20%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"center middle\", minHeight: \"50px\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, hasPlayed && hasPlayed == \"lost\" /* lose */ ? \"Fail\" : `+${BonusValues[displayBonus ?? \"undefined\" /* undefined */] + 1}`), \" :\"), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, hasPlayed ? \"Result\" : \"Bonus\")));\n  case \"won\" /* win */:\n  case \"lost\" /* lose */:\n   return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n    \"button\",\n    {\n     appearance: \"secondary\",\n     icon: \"refresh\",\n     size: \"medium\",\n     onPress: onRetryPress\n    },\n    \"Retry\"\n   ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"large\" }), /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", onPress: onStatsPress, icon: \"contest\", size: \"medium\" }, \"Stats\"), \");\");\n }\n};\n\n// src/components/QuizStats.tsx\nvar QuizStats = async (props, context) => {\n const { redis, cache, userId, postId } = context;\n const data = await cache(async () => {\n  const quizAttempts2 = quizKey(\"attempts\" /* attempts */, postId);\n  const quizSuccesses2 = quizKey(\"successes\" /* successes */, postId);\n  const userAttempts2 = userStatsKey(userId, \"attempts\" /* attempts */);\n  const userSuccesses2 = userStatsKey(userId, \"successes\" /* successes */);\n  const hasPlayed2 = userKey(userId, postId);\n  const data2 = await redis.mget([quizAttempts2, quizSuccesses2, userAttempts2, userSuccesses2, hasPlayed2]);\n  return data2;\n }, {\n  key: \"quiz-stats\",\n  ttl: 1e3\n });\n const quizAttempts = parseInt(data[0] ?? \"0\");\n const quizSuccesses = parseInt(data[1] ?? \"0\");\n const userAttempts = parseInt(data[2] ?? \"0\");\n const userSuccesses = parseInt(data[3] ?? \"0\");\n const userSuccessRate = userAttempts === 0 ? 0 : Math.round(userSuccesses / userAttempts * 100);\n const quizSuccessRate = quizAttempts === 0 ? 0 : Math.round(quizSuccesses / quizAttempts * 100);\n const hasPlayed = data[4] ? data[4] : \"have not attempted this quiz\";\n return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", border: \"thin\", cornerRadius: \"medium\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"50%\", alignment: \"start top\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\" }, \"This Quiz\"), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Attempts: \", quizAttempts), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"% success: \", quizSuccessRate), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"You \", hasPlayed, \" \")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"50%\", alignment: \"start top\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\" }, \"My stats\"), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Attempts: \", userAttempts), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"% success: \", userSuccessRate, \"%\"))));\n};\n\n// src/main.tsx\nDevvit.configure({\n redditAPI: true,\n // context.reddit will now be available\n redis: true\n});\nvar quizCreationForm = Devvit.createForm(\n (data) => {\n  return {\n   title: \"New chess quiz\",\n   acceptLabel: \"Post\",\n   fields: [\n    {\n     name: \"title\",\n     label: \"Post title\",\n     type: \"string\",\n     helpText: 'State the goal of the quiz in the title. E.g. \"Mate in 3\"',\n     defaultValue: data?.title,\n     required: true\n    },\n    // { \n    //  name: 'pgn', \n    //  label: 'Quiz details (PGN)', \n    //  defaultValue: data?.pgn,\n    //  helpText: \"Quiz details in PGN. First move is the lastMove's most recent move with remaining moves describing the solution.\",\n    //  required: true,\n    //  type: 'paragraph',\n    // },\n    {\n     name: \"position\",\n     label: \"Starting position (FEN)\",\n     defaultValue: data?.position,\n     helpText: \"The starting position of the quiz in FEN format.\",\n     type: \"string\",\n     required: true\n    },\n    // { \n    //  name: 'lastMove', \n    //  label: \"Opponent's Last move (SAN)\", \n    //  defaultValue: data?.lastMove,\n    //  helpText: \"The last move made by the opponent (optional)\",\n    //  type: 'string', \n    //  required: false,\n    // },\n    {\n     name: \"solution\",\n     label: \"Solution (SAN)\",\n     defaultValue: data?.solution,\n     helpText: \"The solution to the quiz in SAN format. E.g. 1. e4 e5 2. Nf3 Nc6 3. Bb5\",\n     type: \"string\",\n     required: true\n    },\n    {\n     // toggle setUp to true if the first move in the solution is the opponent's last move\n     name: \"setUp\",\n     label: \"Set up?\",\n     defaultValue: data?.setUp,\n     helpText: \"Check if the first move in the solution is the opponent's last move\",\n     type: \"boolean\",\n     required: true\n    }\n   ]\n  };\n },\n quizCreationHandler\n);\nasync function quizCreationHandler(event, context) {\n const title = event.values.title;\n const position = event.values.position;\n const solution = event.values.solution;\n const setUp = event.values.setUp;\n const reddit = context.reddit;\n const ui = context.ui;\n let currentPosition;\n try {\n  const chess = new Chess(position);\n } catch (e) {\n  ui.showToast(`Quiz creation failed: check inputs. ${e.toString()}`);\n  ui.showForm(quizCreationForm, event.values);\n  return;\n }\n const subreddit = await reddit.getCurrentSubreddit();\n const post = await reddit.submitPost({\n  // This will show while your custom post is loading\n  preview: /* @__PURE__ */ Devvit.createElement(\n   \"zstack\",\n   {\n    height: \"100%\",\n    width: \"100%\",\n    alignment: \"center middle\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageWidth: 788, imageHeight: 512 }),\n   /* @__PURE__ */ Devvit.createElement(\n    \"vstack\",\n    {\n     gap: \"large\",\n     alignment: \"center middle\",\n     padding: \"medium\",\n     cornerRadius: \"medium\",\n     minWidth: \"288px\",\n     height: \"500px\",\n     darkBackgroundColor: \"#131F23\",\n     lightBackgroundColor: \"white\"\n    },\n    /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }),\n    /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading chess quiz...\")\n   )\n  ),\n  title,\n  subredditName: subreddit.name\n });\n const kv = {\n  [quizKey(\"currentPosition\" /* currentPosition */, post.id)]: position,\n  [quizKey(\"solutionMoves\" /* solutionMoves */, post.id)]: solution,\n  [quizKey(\"setUp\" /* setUp */, post.id)]: JSON.stringify(setUp),\n  [quizKey(\"title\" /* title */, post.id)]: title\n };\n await context.redis.mset(kv);\n context.ui.showToast({\n  text: `Chess quiz created!`,\n  appearance: \"success\"\n });\n}\nDevvit.addMenuItem({\n label: \"New chess quiz\",\n location: \"subreddit\",\n onPress: async (_event, context) => {\n  context.ui.showForm(quizCreationForm);\n }\n});\nvar App = async (context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const useInterval = context.useInterval;\n const [page, navigate] = useState(2 /* ACTIVE */);\n switch (page) {\n  case 4 /* LEADERBOARD */:\n   const props = {\n    subredditId: context.subredditId,\n    context\n   };\n   const lb = Leaderboard.fromSubreddit(props);\n   return /* @__PURE__ */ Devvit.createElement(\n    lb.View,\n    {\n     items: 5,\n     onClose: () => {\n      navigate(2 /* ACTIVE */);\n     },\n     footer: /* @__PURE__ */ Devvit.createElement(QuizStats, null)\n    }\n   );\n  case 2 /* ACTIVE */:\n  default:\n   return /* @__PURE__ */ Devvit.createElement(Quiz, { navigate, startPage: true });\n }\n};\nDevvit.addCustomPostType({\n height: \"tall\",\n name: \"Community Chess\",\n render: App\n});\nvar main_default = Devvit;\n\n\nFinally here is an example that implements a survey or poll app. This also has examples of multiple screens, reusable components as well as how to use the redis-like backend for storing data.\n\n// src/PollHelpers.tsx\nvar import_numbro = __toESM(require_numbro_min(), 1);\nvar numbro = import_numbro.default;\nvar formatCount = (count) => {\n return numbro(count).format({\n   average: true,\n   mantissa: 1,\n   optionalMantissa: true,\n   trimMantissa: true,\n   thousandSeparated: true\n });\n};\nfunction shuffle(arr) {\n for (let i = arr.length - 1; i > 0; i--) {\n   const j = Math.floor(Math.random() * (i + 1));\n   const temp = arr[i];\n   arr[i] = arr[j];\n   arr[j] = temp;\n }\n}\nvar undefinedValue = `undefined`;\nvar userKey = (userId, postId) => {\n return `polls:${postId ?? undefinedValue}:${userId ?? undefinedValue}`;\n};\nvar key = (keyType, postId) => {\n return `polls:${postId ?? undefinedValue}:${keyType}`;\n};\nvar resetRedis = async (context) => {\n const redis = context.redis;\n await redis.mset({\n   \"polls:undefined:question\": \"What is your favorite color?\",\n   \"polls:undefined:finish\": (/* @__PURE__ */ new Date()).getTime() + 5 * 60 * 1e3 + \"\",\n   \"polls:undefined:0\": \"0\",\n   \"polls:undefined:1\": \"0\",\n   \"polls:undefined:2\": \"0\"\n });\n const voteds = await redis.zRange(`polls:undefined:voted`, 0, -1);\n if (voteds.length > 0) {\n   await redis.del(...voteds.map((voted) => voted.member));\n }\n await redis.del(`polls:undefined:voted`);\n await redis.zAdd(\n   `polls:undefined:options`,\n   {\n     member: \"Red\",\n     score: 0\n   },\n   {\n     member: \"Green\",\n     score: 1\n   },\n   {\n     member: \"Blue\",\n     score: 2\n   }\n );\n console.log(\"I reset the state\");\n};\n\n// src/components/VotePage.tsx\nvar import_moment = __toESM(require_moment(), 1);\nvar PollOption = ({\n option,\n index,\n selectedOption,\n setSelectedOption\n}) => {\n const selectOption = () => setSelectedOption(index);\n const selected = index === selectedOption;\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }), /* @__PURE__ */ Devvit.createElement(\n   \"hstack\",\n   {\n     width: \"100%\",\n     alignment: \"start middle\",\n     onPress: selectOption,\n     gap: \"small\",\n     \"data-selection\": index\n   },\n   /* @__PURE__ */ Devvit.createElement(\"icon\", { name: selected ? \"radio-button-fill\" : \"radio-button-outline\" }),\n   /* @__PURE__ */ Devvit.createElement(\"text\", { grow: true }, option)\n ));\n};\nvar VotePage = async ({\n options,\n shuffledOptions,\n votes,\n setVotes,\n navigate,\n optionsPerPollPage,\n pollPages,\n remainingMillis,\n allowShowResults,\n randomizeOrder\n}, { redis, useState, userId, postId }) => {\n const remaining = import_moment.default.duration(remainingMillis).humanize();\n const [selectedOption, setSelectedOption] = useState(-1);\n const presentedOptions = randomizeOrder ? shuffledOptions : options;\n const submitVote = async () => {\n   const user = userKey(userId, postId);\n   const tx = await redis.watch(user);\n   const selectedOptionString = presentedOptions[selectedOption];\n   const optionIndex = options.indexOf(selectedOptionString);\n   let already = false;\n   try {\n     already = !!await redis.get(user);\n   } catch {\n   }\n   await tx.multi();\n   await tx.zAdd(key(\"voted\" /* voted */, postId), { member: user, score: 0 });\n   if (already) {\n     await tx.exec();\n   } else {\n     await tx.set(user, optionIndex + \"\");\n     await redis.incrBy(`polls:${postId}:${optionIndex}`, 1);\n     await tx.exec();\n     setVotes(votes.map((v, i) => i === optionIndex ? v + 1 : v));\n   }\n   navigate(1 /* RESULTS */);\n };\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n const prevPollPage = async () => {\n   if (pollPage > 1) {\n     setPollPage(pollPage - 1);\n   }\n };\n const nextPollPage = async () => {\n   if (pollPage < pollPages) {\n     setPollPage(pollPage + 1);\n   }\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { height: \"100%\", width: \"100%\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", color: \"green\" }, \"Open\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", remaining, \" left\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), allowShowResults && /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"plain\", onPress: () => navigate(2 /* CONFIRM */) }, \"View Results\")), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { grow: true }, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"medium\" }, presentedOptions.slice(rangeStart, rangeEnd).map((option, index) => {\n   const props = {\n     option,\n     index: index + rangeStart,\n     selectedOption,\n     setSelectedOption\n   };\n   return /* @__PURE__ */ Devvit.createElement(PollOption, { ...props });\n }))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"15%\", alignment: \"middle\" }, pollPages > 1 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, gap: \"medium\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"back-outline\",\n     onPress: prevPollPage,\n     disabled: pollPage === 1\n   }\n ), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Page \", pollPage, \" of \", pollPages), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"forward-outline\",\n     onPress: nextPollPage,\n     disabled: pollPage === pollPages\n   }\n )), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"medium\",\n     appearance: \"primary\",\n     onPress: submitVote,\n     disabled: selectedOption === -1\n   },\n   \"Vote!\"\n )));\n};\n\n// src/components/ResultsPage.tsx\nvar import_moment2 = __toESM(require_moment(), 1);\nvar PollResult = ({ option, votes, total, winner }) => {\n const percent = Math.max(votes / total * 100, 0.2);\n const nice = formatCount(votes);\n const PercentBar = () => percent >= 0 && /* @__PURE__ */ Devvit.createElement(\n   \"hstack\",\n   {\n     cornerRadius: \"small\",\n     backgroundColor: winner ? \"upvote-background-disabled\" : \"downvote-background-disabled\",\n     width: percent,\n     height: \"100%\",\n     alignment: \"center middle\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"spacer\", { shape: \"square\", size: \"small\" }))\n );\n if (!option && !votes) {\n   return /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"transparent\" }, \"_\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\", borderColor: \"transparent\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"transparent\" }, \"_\")));\n }\n return /* @__PURE__ */ Devvit.createElement(\"zstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(PercentBar, null), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"small\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\" }, nice), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\"text\", { grow: true }, option)));\n};\nvar ResultsPage = async ({\n reset,\n finish,\n setFinish,\n options,\n optionsPerPollPage,\n pollPages,\n votes,\n total,\n remainingMillis,\n navigate\n}, { postId, useState }) => {\n const remaining = import_moment2.default.duration(remainingMillis).humanize();\n const max = Math.max(...votes);\n const zipped = options.map((option, index) => ({\n   option,\n   votes: votes[index],\n   total,\n   winner: votes[index] === max\n }));\n zipped.sort((a, b) => b.votes - a.votes);\n const three = 3 * 60 * 1e3;\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n const prevPollPage = async () => {\n   if (pollPage > 1) {\n     setPollPage(pollPage - 1);\n   }\n };\n const nextPollPage = async () => {\n   if (pollPage < pollPages) {\n     setPollPage(pollPage + 1);\n   }\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", padding: \"medium\" }, remainingMillis > 0 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", color: \"green\" }, \"Open\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", remaining, \" left\")), remainingMillis <= 0 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\" }, \"Closed\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", formatCount(total), \" votes\")), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"small\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), zipped.slice(rangeStart, rangeEnd).map((props) => {\n   return /* @__PURE__ */ Devvit.createElement(PollResult, { ...props });\n })), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"15%\", alignment: \"middle\" }, pollPages > 1 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, gap: \"medium\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"back-outline\",\n     onPress: prevPollPage,\n     disabled: pollPage === 1\n   }\n ), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Page \", pollPage, \" of \", pollPages), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"forward-outline\",\n     onPress: nextPollPage,\n     disabled: pollPage === pollPages\n   }\n ))), !postId && // i.e. only in development mode.\n /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Local debug panel\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     onPress: async () => {\n       await reset();\n       navigate(0 /* VOTE */);\n     }\n   },\n   \"Reset\"\n ), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => navigate(0 /* VOTE */) }, \"Vote again\"), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => setFinish(finish + three) }, \"+3 minutes\"), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => setFinish(finish - three) }, \"-3 minutes\"))));\n};\n\n// src/components/CreatePoll.tsx\nvar addPoll = Devvit.createForm(\n {\n   title: \"Add a poll\",\n   acceptLabel: \"Post\",\n   fields: [\n     {\n       name: \"question\",\n       label: \"Question\",\n       type: \"string\",\n       required: true,\n       helpText: `E.g. What is your favorite color?`\n     },\n     // Description will be used as post selftext, once that is supported for custom posts\n     // {\n     //   name: `description`,\n     //   label: `Description (Optional)`,\n     //   type: `string`,\n     // },\n     {\n       name: \"answers\",\n       label: \"Answers (up to 12 total, use a comma to separate)\",\n       type: \"paragraph\",\n       required: true,\n       helpText: `E.g. \"Red, Orange, Blue, Mother of Pearl\"`\n     },\n     {\n       name: \"days\",\n       label: \"Days to allow voting\",\n       type: \"string\",\n       defaultValue: `2`,\n       required: true\n     },\n     {\n       name: \"randomizeOrder\",\n       label: \"Shuffle order of poll options\",\n       type: \"boolean\",\n       defaultValue: true,\n       helpText: `To reduce bias, options will be presented to the user in a shuffled order.`\n     },\n     {\n       name: \"allowShowResults\",\n       label: 'Include \"Show Results\" option',\n       type: \"boolean\",\n       defaultValue: true,\n       helpText: `This allow users to see poll results without voting. Users cannot vote after viewing the results.`\n     }\n   ]\n },\n async (event, { reddit, subredditId, ui, redis }) => {\n   const sub = await reddit.getSubredditById(subredditId);\n   const answers = event.values.answers.split(\",\").filter((answer) => answer.trim() !== \"\").slice(0, 12).map((answer, i) => ({ member: answer.trim(), score: i }));\n   if (answers.length < 2) {\n     ui.showToast({\n       text: \"Post Failed - You must include at least 2 poll options.\",\n       appearance: \"neutral\"\n     });\n     return;\n   }\n   const options = {\n     subredditName: sub.name,\n     title: event.values.question,\n     // text: \"TODO - description/selftext\",\n     preview: /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Loading...\"))\n   };\n   const post = await reddit.submitPost(options);\n   const timestamp = (/* @__PURE__ */ new Date()).getTime() + parseInt(event.values.days) * 24 * 60 * 60 * 1e3;\n   const allowShowResults = event.values.allowShowResults ? \"true\" : \"false\";\n   const randomizeOrder = event.values.randomizeOrder ? \"true\" : \"false\";\n   await redis.set(key(\"finish\" /* finish */, post.id), timestamp + \"\");\n   await redis.set(key(\"question\" /* question */, post.id), event.values.question);\n   await redis.set(key(\"description\" /* description */, post.id), event.values.description);\n   await redis.zAdd(key(\"options\" /* options */, post.id), ...answers);\n   await redis.set(key(\"allowShowResults\" /* allowShowResults */, post.id), allowShowResults);\n   await redis.set(key(\"randomizeOrder\" /* randomizeOrder */, post.id), randomizeOrder);\n   ui.showToast(\"Poll created!\");\n }\n);\n\n// src/components/ConfirmPage.tsx\nvar ConfirmPage = async ({ votes, setVotes, navigate }, { redis, userId, postId }) => {\n const skipOption = -2;\n const skipVote = async () => {\n   const user = userKey(userId, postId);\n   const tx = await redis.watch(user);\n   let already = false;\n   try {\n     already = !!await redis.get(user);\n   } catch {\n   }\n   await tx.multi();\n   await tx.zAdd(key(\"voted\" /* voted */, postId), { member: user, score: 0 });\n   if (already) {\n     await tx.exec();\n   } else {\n     await tx.set(user, skipOption + \"\");\n     await redis.incrBy(`polls:${postId}:${skipOption}`, 1);\n     await tx.exec();\n     setVotes(votes.map((v, i) => i === skipOption ? v + 1 : v));\n   }\n   navigate(1 /* RESULTS */);\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { grow: true, alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\" }, \"Are you sure?\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"You will not be able to vote after viewing the results.\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { size: \"large\", appearance: \"secondary\", onPress: () => navigate(0 /* VOTE */) }, \"Go back to vote\"), /* @__PURE__ */ Devvit.createElement(\"button\", { size: \"large\", appearance: \"destructive\", onPress: () => skipVote() }, \"Show me the results!\")));\n};\n\n// src/main.tsx\nDevvit.configure({\n redis: true,\n redditAPI: true\n});\nvar App = async (context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const [page, navigate] = useState(async () => {\n   let hasVoted = false;\n   try {\n     hasVoted = !!await redis.get(userKey(userId, postId));\n   } catch {\n   }\n   return hasVoted ? 1 /* RESULTS */ : 0 /* VOTE */;\n });\n useState(async () => {\n   if (postId)\n     return;\n   if (!await redis.get(key(\"question\" /* question */, `undefined`))) {\n     await resetRedis(context);\n   }\n });\n const [currentUserId] = useState(userId);\n const [options] = useState(async () => {\n   const options2 = await redis.zRange(key(\"options\" /* options */, postId), 0, -1);\n   return options2.map((option) => option.member);\n });\n const [shuffledOptions] = useState(async () => {\n   const array = [...options];\n   shuffle(array);\n   return array;\n });\n const [votes, setVotes] = useState(async () => {\n   const rsp = await redis.mget(options.map((_option, i) => `polls:${postId}:${i}`));\n   return rsp.map((count) => parseInt(count || \"0\"));\n });\n const reset = async () => {\n   await resetRedis(context);\n   setVotes([0, 0, 0]);\n   setFinish((/* @__PURE__ */ new Date()).getTime() + 5 * 60 * 1e3);\n };\n const total = votes.reduce((a, b) => a + b, 0);\n const now = (/* @__PURE__ */ new Date()).getTime();\n const [finish, setFinish] = useState(async () => {\n   const finish2 = await redis.get(key(\"finish\" /* finish */, postId));\n   return parseInt(finish2 || \"0\");\n });\n const remainingMillis = finish - now;\n const [description, _setDescription] = useState(async () => {\n   return await redis.get(key(\"description\" /* description */, postId));\n });\n const [allowShowResults, _setAllowShowResults] = useState(async () => {\n   const allow = await redis.get(key(\"allowShowResults\" /* allowShowResults */, postId));\n   return allow === \"true\";\n });\n const [randomizeOrder, _setRandomizeOrder] = useState(async () => {\n   const randomize = await redis.get(key(\"randomizeOrder\" /* randomizeOrder */, postId));\n   return randomize === \"true\";\n });\n const optionsPerPollPage = 4;\n const pollPages = Math.ceil(options.length / optionsPerPollPage);\n const props = {\n   navigate,\n   options,\n   shuffledOptions,\n   optionsPerPollPage,\n   pollPages,\n   setFinish,\n   votes,\n   description,\n   finish,\n   total,\n   setVotes,\n   remainingMillis,\n   allowShowResults,\n   randomizeOrder,\n   reset\n };\n if (!currentUserId) {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Not logged in\"));\n } else if (page === 0 /* VOTE */ && remainingMillis > 0) {\n   return /* @__PURE__ */ Devvit.createElement(VotePage, { ...props });\n } else if (page === 2 /* CONFIRM */ && remainingMillis > 0) {\n   return /* @__PURE__ */ Devvit.createElement(ConfirmPage, { ...props });\n } else {\n   return /* @__PURE__ */ Devvit.createElement(ResultsPage, { ...props });\n }\n};\nDevvit.addMenuItem({\n label: \"Create a new poll\",\n location: \"subreddit\",\n onPress: (_event, context) => {\n   context.ui.showForm(addPoll);\n }\n});\nDevvit.addCustomPostType({\n name: \"Polls Plus\",\n description: \"Polls but better\",\n render: App\n});\nvar main_default = Devvit;\n\n\none more thing: here is an example of how JSX syntax can be used instead of calls like Devvit.createElement. This example creates a progress bar with two buttons to increase and decrease the progress a users sees on screen. Where possible, JSX should be used instead of Devvit.createElement.\n\nimport {Devvit} from '@devvit/public-api'\n\nDevvit.addCustomPostType({\n name: 'Progress bar example',\n render: context => {\n  const [progress, setProgress] = context.useState(30)\n  return (\n   <vstack\n    alignment='center middle'\n    height='100%'\n    gap='medium'\n    padding='large'\n   >\n    <vstack backgroundColor='#FFD5C6' cornerRadius='full' width='100%'>\n     <hstack backgroundColor='#D93A00' width={`${progress}%`}>\n      <spacer size='medium' shape='square' />\n     </hstack>\n    </vstack>\n    <hstack gap='medium' width='100%'>\n     <button\n      icon='subtract-fill'\n      width='50%'\n      onPress={() => setProgress(progress => Math.max(progress - 10, 0))}\n     />\n     <button\n      icon='add-fill'\n      width='50%'\n      onPress={() =>\n       setProgress(progress => Math.min(progress + 10, 100))\n      }\n     />\n    </hstack>\n   </vstack>\n  )\n }\n})\n\nexport default Devvit",
  }];

export const code_only = [{text:
    "/* \nI want to create code using a new API called Devvit. I'm going to provide some context which will include documentation about Devvit. This includes code samples as well as interface specifications. Devvit apps (sometimes called custom posts) are written in Typescript. When writing code using devvit keep the following in mind:\n\n1) devvit is similar to react, but it is not react. React code will not work in de\nvvit.  \n2) It is good practice to break code into reusable components.\n3) every file should begin importing devvit, e.g. import {Devvit} from '@devvit/public-api' and end with `export default Devvit;`\n4) Devvit allows the use of JSX. The JSX components here do not use CSS styles. Look at the provided examples for how to style text.\n5) Code will be evaluated against a strict Typescript interpreter. All variables should have an explicity type.\n6) Every response should be in JSON format with the complete, executable code in a \"code\" element and a tweet-length description of what you did in a \"description\" element. For example { code: \"//code goes here\", description : \"A short description of what you did.\"}\n\nNext, I will include code from 9 example apps to illustrate how to write devvit code.\n*/\n\nimport { Devvit } from '@devvit/public-api';\nimport BlockComponent = Devvit.BlockComponent;\nimport SizeString = Devvit.Blocks.SizeString;\n\ntype BarProps = {\n width?: SizeString | undefined;\n fillWidth?: SizeString | undefined;\n minWidth?: SizeString | undefined;\n maxWidth?: SizeString | undefined;\n};\n\nexport const Bar: BlockComponent<BarProps> = ({ width, fillWidth, minWidth, maxWidth }) => (\n <hstack\n  border={'thin'}\n  cornerRadius={'small'}\n  width={width ?? '100%'}\n  minWidth={minWidth ?? '0px'}\n  maxWidth={maxWidth ?? '100%'}\n >\n  <hstack backgroundColor={'#0045AC'} width={fillWidth ?? '100%'} height={'8px'} />\n </hstack>\n);\nimport { Devvit } from '@devvit/public-api';\n\nimport {\n ButtonPage,\n ColorPage,\n HomePage,\n IconPage,\n ImagePage,\n Page,\n SizePage,\n SpacerPage,\n StacksPage,\n TextPage,\n} from '../pages/index.js';\nimport type { GalleryState } from '../state/state.js';\n\nexport type BlockGalleryProps = {\n state: GalleryState;\n};\n\nexport const BlockGallery = ({ state }: BlockGalleryProps): JSX.Element => {\n const page = state.currentPage;\n const pageState = state.pageState(page);\n return (\n  <vstack padding=\"medium\" grow>\n   {page === Page.HOME && <HomePage state={state} />}\n   {page === Page.BUTTONS && <ButtonPage state={pageState} />}\n   {page === Page.IMAGES && <ImagePage state={pageState} />}\n   {page === Page.SPACERS && <SpacerPage state={pageState} />}\n   {page === Page.STACKS && <StacksPage state={pageState} />}\n   {page === Page.TEXT && <TextPage state={pageState} />}\n   {page === Page.ICON && <IconPage state={pageState} />}\n   {page === Page.COLOR && <ColorPage state={pageState} />}\n   {page === Page.SIZE && <SizePage state={pageState} />}\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nexport type BoxProps = {\n spacerSize?: Devvit.Blocks.SpacerSize;\n size?: number;\n color?: string;\n rounded?: boolean;\n};\n\nconst SIZE_PX: Record<Devvit.Blocks.SpacerSize, number> = {\n xsmall: 4,\n small: 8,\n medium: 16,\n large: 32,\n};\n\nexport const Box = ({\n spacerSize = 'large',\n size = 1,\n color,\n rounded = false,\n}: BoxProps): JSX.Element => {\n const sizePx: Devvit.Blocks.SizePixels = `${SIZE_PX[spacerSize] * size}px`;\n return (\n  <hstack\n   backgroundColor={color}\n   cornerRadius={rounded ? 'full' : 'none'}\n   width={sizePx}\n   height={sizePx}\n  />\n );\n};\nimport type { UseStateResult } from '@devvit/public-api';\nimport { Devvit } from '@devvit/public-api';\nimport type { StatefulProps } from '../state/state.js';\nimport { Tabs } from './Tabs.js';\n\nexport class CategoryPageState {\n readonly _category: UseStateResult<string>;\n readonly _subcategory: UseStateResult<string>;\n readonly _goHome: () => void;\n\n constructor({ useState, goHome }: StatefulProps, defaultCategory: string = '') {\n  this._category = useState<string>(defaultCategory);\n  this._subcategory = useState<string>('');\n  this._goHome = goHome;\n }\n\n get category(): string {\n  return this._category[0];\n }\n\n set category(value: string) {\n  this._category[1](value);\n  this.subcategory = '';\n }\n\n setCategory = (value: string): void => {\n  this.category = value;\n };\n\n get subcategory(): string {\n  return this._subcategory[0];\n }\n\n set subcategory(value: string) {\n  this._subcategory[1](value);\n }\n\n setSubCategory = (value: string): void => {\n  this.subcategory = value;\n };\n\n goHome = (): void => this._goHome();\n}\n\nexport type SharedCategoryPageProps = {\n state: CategoryPageState;\n};\n\nexport type CategoryPageProps = SharedCategoryPageProps & {\n title?: string;\n categories: CategoryProps[];\n activeCategory: string;\n onCategoryChanged: (category: string) => void;\n subCategoryPage?: boolean;\n};\n\nexport type CategoryProps = {\n label: string;\n category: string;\n content: JSX.Element | JSX.Element[];\n};\n\nexport const CategoryPage = (props: CategoryPageProps): JSX.Element => {\n const activeCategory = props.activeCategory || props.categories[0].category;\n return (\n  <vstack gap=\"small\" grow>\n   {/* Header */}\n   {props.subCategoryPage ? (\n    <></>\n   ) : (\n    <hstack alignment=\"start middle\" gap=\"small\">\n     <button onPress={props.state?.goHome} appearance=\"secondary\" size=\"small\" icon=\"back\" />\n     <text selectable={false} size=\"xlarge\" weight=\"bold\" color=\"neutral-content\">\n      {props.title}\n     </text>\n    </hstack>\n   )}\n\n   <Tabs\n    tabs={props.categories.map(({ label, category }) => ({\n     label,\n     isActive: category === activeCategory,\n     onPress: () => {\n      props.onCategoryChanged(category);\n     },\n    }))}\n   />\n\n   {\n    // Page contents\n    props.categories.find((page) => page.category === activeCategory)?.content ?? null\n   }\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\ntype ColumnsProps = {\n count: number;\n children: JSX.Children;\n};\n\nexport const Columns = ({ count, children }: ColumnsProps): JSX.Element => {\n const rows: JSX.Element[] = [];\n\n // Divide the children into rows with N (count) children each.\n // Pad the last row if incomplete.\n for (let i = 0; i < children.length; i += count) {\n  const row = children\n   .slice(i, i + count)\n   .map((child) => <vstack width={100.0 / count}>{child}</vstack>);\n  const rowHasRoom = (): boolean => row.length < count;\n  while (rowHasRoom()) row.push(<hstack width={100.0 / count} />);\n  rows.push(<hstack gap=\"small\">{row}</hstack>);\n }\n\n return <vstack gap=\"small\">{rows}</vstack>;\n};\nimport { Devvit } from '@devvit/public-api';\n\ntype TabsProps = { tabs: TabProps[] };\ntype TabProps = { label: string; isActive: boolean; onPress: () => void };\n\nconst Tab = ({ label, isActive, onPress }: TabProps): JSX.Element => {\n return (\n  <button appearance={isActive ? 'primary' : 'secondary'} size=\"small\" onPress={onPress}>\n   {label}\n  </button>\n );\n};\n\nexport const Tabs = ({ tabs }: TabsProps): JSX.Element => {\n return (\n  <hstack alignment=\"start\" gap=\"small\">\n   {tabs.map(({ label, isActive, onPress }) => (\n    <Tab label={label} isActive={isActive} onPress={onPress} />\n   ))}\n  </hstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nexport type TileProps = {\n label?: string | undefined;\n padding?: Devvit.Blocks.ContainerPadding | undefined;\n children: JSX.Element | JSX.Element[];\n};\n\nexport const Tile = (props: TileProps): JSX.Element => {\n const { label, children } = props;\n return (\n  <vstack\n   padding={props.padding ?? 'medium'}\n   border=\"thick\"\n   borderColor=\"neutral-border-weak\"\n   cornerRadius=\"small\"\n   gap=\"small\"\n   grow\n  >\n   <hstack alignment=\"start middle\" grow>\n    {children}\n   </hstack>\n   {label ? (\n    <text selectable={false} color=\"neutral-content-weak\">\n     {label}\n    </text>\n   ) : (\n    <></>\n   )}\n  </vstack>\n );\n};\nimport { ContextAPIClients, Devvit } from '@devvit/public-api';\n\nimport { BlockGallery } from './components/BlockGallery.js';\nimport { GalleryState } from './state/state.js';\n\nDevvit.debug.emitSnapshots = true;\n\nDevvit.configure({\n redditAPI: true,\n});\n\nDevvit.addMenuItem({\n label: 'Blocks Gallery: Create a post',\n location: 'subreddit',\n async onPress(_, { reddit, ui }) {\n  const currentSubreddit = await reddit.getCurrentSubreddit();\n  await reddit.submitPost({\n   title: 'Blocks Gallery',\n   subredditName: currentSubreddit.name,\n   preview: (\n    <vstack alignment={'middle center'} grow>\n     <text>Loading blocks gallery</text>\n    </vstack>\n   ),\n  });\n\n  ui.showToast('Posted a blocks gallery!');\n },\n});\n\nDevvit.addCustomPostType({\n name: 'Blocks Gallery',\n description: 'Demonstrates the blocks elements',\n height: 'tall',\n render: (renderContext: ContextAPIClients) => {\n  const state = new GalleryState(renderContext);\n  return <BlockGallery state={state} />;\n },\n});\n\nexport default Devvit;\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const ButtonAppearanceCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ButtonAppearance][] = [\n  ['Primary', 'primary'],\n  ['Secondary *', 'secondary'],\n  ['Plain', 'plain'],\n  ['Bordered', 'bordered'],\n  ['Destructive', 'destructive'],\n  ['Media', 'media'],\n  ['Success', 'success'],\n ];\n\n const content = options.map(([label, appearance]) => {\n  return (\n   <Tile label={label} padding={'small'}>\n    <button appearance={appearance}>Label</button>\n   </Tile>\n  );\n });\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ButtonContentCategory = (): JSX.Element => {\n return (\n  <vstack>\n   <Columns count={3}>\n    <Tile label=\"Label\">\n     <button>Label</button>\n    </Tile>\n    <Tile label=\"Icon\">\n     <button icon=\"upvote-outline\">Label</button>\n    </Tile>\n    <Tile label=\"Label and icon\">\n     <button icon=\"chat-outline\">Chat</button>\n    </Tile>\n   </Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ButtonDisabledCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ButtonAppearance][] = [\n  ['Primary', 'primary'],\n  ['Secondary *', 'secondary'],\n  ['Plain', 'plain'],\n  ['Bordered', 'bordered'],\n  ['Destructive', 'destructive'],\n  ['Media', 'media'],\n  ['Success', 'success'],\n ];\n\n const content = options.map(([label, appearance]) => (\n  <Tile label={label} padding={'small'}>\n   <hstack gap=\"small\">\n    <button appearance={appearance}>Enabled</button>\n    <button appearance={appearance} disabled>\n     Disabled\n    </button>\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ButtonGrowCategory = (): JSX.Element => {\n const options: [string, boolean][] = [\n  ['False *', false],\n  ['True', true],\n ];\n\n const content = options.map(([label, style]) => (\n  <Tile label={label}>\n   <button grow={style}>Label</button>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit, IconName } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ButtonIconCategory = (): JSX.Element => {\n const icons: IconName[] = ['bot', 'bot-fill', 'topic-funny', 'topic-funny-fill'];\n\n const content = icons.map((icon: IconName) => (\n  <Tile label={icon}>\n   <button appearance={'primary'} icon={icon}>\n    Label\n   </button>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { ButtonAppearanceCategory } from './ButtonAppearanceCategory.js';\nimport { ButtonSizeCategory } from './ButtonSizeCategory.js';\nimport { ButtonContentCategory } from './ButtonContentCategory.js';\nimport { ButtonGrowCategory } from './ButtonGrowCategory.js';\nimport { ButtonDisabledCategory } from './ButtonDisabledCategory.js';\nimport type { SharedCategoryPageProps, CategoryProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { Page } from '../page.js';\nimport { ButtonIconCategory } from './ButtonIconCategory.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\nexport const ButtonPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Appearances',\n   category: 'appearance',\n   content: <ButtonAppearanceCategory />,\n  },\n  {\n   label: 'Sizes',\n   category: 'size',\n   content: <ButtonSizeCategory />,\n  },\n  {\n   label: 'Contents',\n   category: 'content',\n   content: <ButtonContentCategory />,\n  },\n  {\n   label: 'Grow',\n   category: 'grow',\n   content: <ButtonGrowCategory />,\n  },\n  {\n   label: 'Disabled',\n   category: 'disabled',\n   content: <ButtonDisabledCategory />,\n  },\n  {\n   label: 'Icons',\n   category: 'icons',\n   content: <ButtonIconCategory />,\n  },\n ];\n\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.BUTTONS)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ButtonSizeCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ButtonSize][] = [\n  ['Small (32 dp)', 'small'],\n  ['Medium (40 dp) *', 'medium'],\n  ['Large (48 dp)', 'large'],\n ];\n\n const content = options.map(([label, size]) => {\n  return (\n   <Tile label={label}>\n    <button appearance=\"secondary\" size={size}>\n     Label\n    </button>\n   </Tile>\n  );\n });\n content.push(\n  ...options.map(([label, size]) => {\n   return (\n    <Tile label={label}>\n     <button appearance=\"secondary\" size={size} icon=\"admin\">\n      Label\n     </button>\n    </Tile>\n   );\n  })\n );\n\n return (\n  <vstack>\n   <Columns count={3}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { Page } from '../page.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\nimport { ColorSubcategoryPage } from './ColorSubcategoryPage.js';\nimport { ColorPrimitivesPage } from './ColorPrimitivesPage.js';\nimport { ColorSemanticPage } from './ColorSemanticPage.js';\n\nconst hexCategories = [\n ['#RRGGBB', 'six'],\n ['#RGB', 'three'],\n ['#RRGGBBAA', 'eight'],\n ['#RGBA', 'four'],\n];\n\nconst rgbCategories = [\n ['rgb()', ''],\n ['rgba()', 'a'],\n];\n\n// TODO: Uncomment once HSL is supported in public-api (DXR-440)\n// const hslCategories = [\n//  ['hsl()', ''],\n//  ['hsla()', 'a'],\n// ];\n\nexport const ColorPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Hex',\n   category: 'hex',\n   content: <ColorSubcategoryPage state={state} subcategories={hexCategories} />,\n  },\n  {\n   label: 'RGB',\n   category: 'rgb',\n   content: <ColorSubcategoryPage state={state} subcategories={rgbCategories} />,\n  },\n  // TODO: Uncomment once HSL is supported in public-api (DXR-440)\n  // {\n  //  label: 'HSL',\n  //  category: 'hsl',\n  //  content: <ColorSubcategoryPage state={state} subcategories={hslCategories} />,\n  // },\n  {\n   label: 'Primitives',\n   category: 'primitives',\n   content: <ColorPrimitivesPage state={state} />,\n  },\n  {\n   label: 'Semantic',\n   category: 'semantic',\n   content: <ColorSemanticPage />,\n  },\n ];\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.COLOR)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\nimport { CategoryPageState } from '../../components/CategoryPage.js';\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nimport { COLOR } from './colors.js';\n\nexport const ColorPreview = ({\n state,\n defaultSubcategory,\n}: {\n state: CategoryPageState;\n defaultSubcategory: string;\n}): JSX.Element => {\n return (\n  <Columns count={2}>\n   {Object.entries(COLOR).map(([colorName, colorValues]) => {\n    const subcategory = state.subcategory || defaultSubcategory;\n    const suffix = subcategory && `-${subcategory}`;\n    const key = `${state.category}${suffix}`;\n    return (\n     <Tile label={`${StringUtil.capitalize(colorName)}: ${colorValues[key]}`}>\n      <zstack>\n       <image\n        url={'checkerboard.png'}\n        imageWidth={32}\n        imageHeight={32}\n        resizeMode={'none'}\n       />\n       <hstack\n        backgroundColor={colorValues[key]}\n        border={'thin'}\n        borderColor={'neutral-content'}\n       >\n        <spacer size={'large'} shape={'square'} />\n       </hstack>\n      </zstack>\n     </Tile>\n    );\n   })}\n  </Columns>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { CategoryPage, CategoryPageState } from '../../components/CategoryPage.js';\nimport { ColorPrimitivePreview } from './ColorPrimitivesPreview.js';\n\nexport const ColorPrimitivesPage = ({ state }: { state: CategoryPageState }): JSX.Element => {\n const colors = ['AlienBlue', 'SakuraPink', 'KiwiGreen'];\n const categories = colors.map((name) => ({\n  label: name,\n  category: name,\n  content: <ColorPrimitivePreview name={name} />,\n }));\n\n return (\n  <CategoryPage\n   state={state}\n   subCategoryPage\n   categories={categories}\n   activeCategory={state.subcategory}\n   onCategoryChanged={state.setSubCategory}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ColorPrimitivePreview = ({ name }: { name: string }): JSX.Element => {\n const tones = [100, 300, 500, 700];\n return (\n  <Columns count={2}>\n   {tones.map((tone) => {\n    const color = `${name}-${tone}`;\n    return (\n     <Tile label={color}>\n      <hstack backgroundColor={color} border={'thin'} borderColor={'neutral-content'}>\n       <spacer size={'large'} shape={'square'} />\n      </hstack>\n     </Tile>\n    );\n   })}\n  </Columns>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const ColorSemanticPage = (): JSX.Element => {\n const colors = [\n  'neutral-content',\n  'secondary-content',\n  'danger-background',\n  'brand-background',\n  'success-background',\n  'warning-background',\n ];\n return (\n  <Columns count={2}>\n   {colors.map((name) => (\n    <Tile label={name}>\n     <hstack backgroundColor={name} border={'thin'} borderColor={'neutral-content'}>\n      <spacer size={'large'} shape={'square'} />\n     </hstack>\n    </Tile>\n   ))}\n  </Columns>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { CategoryPage, CategoryPageState } from '../../components/CategoryPage.js';\nimport { ColorPreview } from './ColorPreview.js';\n\nexport const ColorSubcategoryPage = ({\n state,\n subcategories,\n}: {\n state: CategoryPageState;\n subcategories: string[][];\n}): JSX.Element => {\n const content = <ColorPreview state={state} defaultSubcategory={subcategories[0][1]} />;\n const categories = subcategories.map(([label, category]) => ({\n  label,\n  category,\n  content,\n }));\n\n return (\n  <CategoryPage\n   state={state}\n   subCategoryPage\n   categories={categories}\n   activeCategory={state.subcategory}\n   onCategoryChanged={state.setSubCategory}\n  />\n );\n};\nexport const COLOR: Record<string, Record<string, string>> = {\n red: {\n  'hex-six': '#ff0000',\n  'hex-three': '#f00',\n  'hex-eight': '#ff000088',\n  'hex-four': '#f008',\n  rgb: 'rgb(255, 0, 0)',\n  'rgb-a': 'rgba(255, 0, 0, 0.5)',\n  hsl: 'hsl(0, 100%, 50%)',\n  'hsl-a': 'hsl(0, 100%, 50%, 50%)',\n },\n green: {\n  'hex-six': '#00ff00',\n  'hex-three': '#0f0',\n  'hex-eight': '#00ff0088',\n  'hex-four': '#0f08',\n  rgb: 'rgb(0, 255, 0)',\n  'rgb-a': 'rgba(0, 255, 0, 0.5)',\n  hsl: 'hsl(120, 100%, 50%)',\n  'hsl-a': 'hsl(120, 100%, 50%, 50%)',\n },\n blue: {\n  'hex-six': '#0000ff',\n  'hex-three': '#00f',\n  'hex-eight': '#0000ff88',\n  'hex-four': '#00f8',\n  rgb: 'rgb(0, 0, 255)',\n  'rgb-a': 'rgba(0, 0, 255, 0.5)',\n  hsl: 'hsl(240, 100%, 50%)',\n  'hsl-a': 'hsl(240, 100%, 50%, 50%)',\n },\n magenta: {\n  'hex-six': '#ff00ff',\n  'hex-three': '#f0f',\n  'hex-eight': '#ff00ff88',\n  'hex-four': '#f0f8',\n  rgb: 'rgb(255, 0, 255)',\n  'rgb-a': 'rgba(255, 0, 255, 0.5)',\n  hsl: 'hsl(300, 100%, 50%)',\n  'hsl-a': 'hsl(300, 100%, 50%, 50%)',\n },\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { BlockGalleryProps } from '../../components/BlockGallery.js';\n\nexport const HomePage = ({ state }: BlockGalleryProps): JSX.Element => {\n const pages: string[][] = [\n  ['Button', 'buttons'],\n  ['Image', 'images'],\n  ['Stack', 'stacks'],\n  ['Spacer', 'spacers'],\n  ['Text', 'text'],\n  ['Icon', 'icon'],\n  ['Color', 'color'],\n  ['Size', 'size'],\n ];\n\n const pageButtons = pages.map(([label, id]) => (\n  <button\n   onPress={() => {\n    state.currentPage = id;\n   }}\n  >\n   {label}\n  </button>\n ));\n\n return (\n  <vstack gap=\"medium\">\n   <vstack>\n    <text\n     selectable={false}\n     size=\"xlarge\"\n     weight=\"bold\"\n     color=\"neutral-content\"\n     onPress={() => {\n      state.showToast('Hello, world!');\n     }}\n    >\n     Block Gallery\n    </text>\n    <text selectable={false} size=\"medium\" color=\"neutral-content-weak\">\n     Version 2.0\n    </text>\n   </vstack>\n\n   <Columns count={2}>{pageButtons}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { Page } from '../page.js';\nimport { IconsCategory } from './IconsCategory.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\nimport { IconSizeCategory } from './IconSizeCategory.js';\n\nexport const IconPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Examples',\n   category: 'examples',\n   content: <IconsCategory state={state} />,\n  },\n  {\n   label: 'Size',\n   category: 'size',\n   content: <IconSizeCategory />,\n  },\n ];\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.ICON)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport IconSize = Devvit.Blocks.IconSize;\nimport { Tile } from '../../components/Tile.js';\n\nconst sizes: IconSize[] = ['xsmall', 'small', 'medium', 'large'];\n\nexport const IconSizeCategory = (): JSX.Element => {\n const icons = sizes.map((size) => (\n  <Tile label={size}>\n   <icon name={'admin-fill'} size={size} />\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{icons}</Columns>\n  </vstack>\n );\n};\nimport { Devvit, IconName } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\nimport { CategoryPage, SharedCategoryPageProps } from '../../components/CategoryPage.js';\n\nfunction getIcons(type: string = ''): JSX.Element[] {\n const iconNames = ['bot', 'topic-programming', 'original', 'karma'];\n const iconColors = ['black', 'blue', 'green', 'red'];\n\n return iconNames.map((name, index) => (\n  <Tile label={name}>\n   <icon name={`${name}${type ? '-' : ''}${type}` as IconName} color={iconColors[index]} />\n  </Tile>\n ));\n}\n\nconst defaultIcons = getIcons();\nconst outlineIcons = getIcons('outline');\nconst fillIcons = getIcons('fill');\n\nconst iconCategories = [\n { label: 'Default', category: 'default', content: <Columns count={2}>{defaultIcons}</Columns> },\n { label: 'Outline', category: 'outline', content: <Columns count={2}>{outlineIcons}</Columns> },\n { label: 'Fill', category: 'fill', content: <Columns count={2}>{fillIcons}</Columns> },\n];\n\nexport const IconsCategory = ({ state }: SharedCategoryPageProps): JSX.Element => {\n return (\n  <CategoryPage\n   state={state}\n   categories={iconCategories}\n   activeCategory={state.subcategory}\n   onCategoryChanged={state.setSubCategory}\n   subCategoryPage\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { Page } from '../page.js';\nimport { ImageResizePreview } from './ImageResizePreview.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\ntype ImageMode = [string, Devvit.Blocks.ImageResizeMode];\n\nexport const ImagePage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const imageModes: ImageMode[] = [\n  ['None', 'none'],\n  ['Fit *', 'fit'],\n  ['Fill', 'fill'],\n  ['Cover', 'cover'],\n  ['Scale Down', 'scale-down'],\n ];\n\n const categories: CategoryProps[] = imageModes.map(([label, mode]) => ({\n  label,\n  category: mode,\n  content: <ImageResizePreview mode={mode} />,\n }));\n\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.IMAGES)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const ImageResizeModeCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ImageResizeMode][] = [\n  ['None', 'none'],\n  ['Fit *', 'fit'],\n  ['Fill', 'fill'],\n  ['Cover', 'cover'],\n  ['Scale Down', 'scale-down'],\n ];\n\n const content = options.map(([label, style]) => (\n  <Tile label={label}>\n   <hstack backgroundColor=\"#EAEDEF\">\n    <image url=\"Snoo.png\" resizeMode={style} imageHeight={128} imageWidth={512} />\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={1}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\n\nexport const ImageResizePreview = ({\n mode,\n}: {\n mode: Devvit.Blocks.ImageResizeMode;\n}): JSX.Element => {\n return (\n  <Tile>\n   <hstack backgroundColor=\"#EAEDEF\">\n    <image url=\"Snoo.png\" resizeMode={mode} imageHeight={128} imageWidth={512} />\n   </hstack>\n  </Tile>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport BlockComponent = Devvit.BlockComponent;\n\nconst Example: BlockComponent<{ width: number; height: number }> = ({ width, height }) => (\n <Tile label={`Size: ${width}px x ${height}px`}>\n  <hstack width={`${width}px`} height={`${height}px`} backgroundColor={'#0045AC'} />\n </Tile>\n);\n\nexport const SizeAbsoluteCategory = () => (\n <hstack gap={'small'}>\n  <vstack gap={'small'}>\n   <Example width={20} height={33} />\n   <Example width={121} height={55} />\n  </vstack>\n  <vstack gap={'small'}>\n   <Example width={42} height={42} />\n   <Example width={64} height={16} />\n  </vstack>\n </hstack>\n);\nimport { Devvit } from '@devvit/public-api';\nimport { Bar } from '../../components/Bar.js';\nimport { Tile } from '../../components/Tile.js';\n\nexport const SizeConstraintsCategory = () => (\n <vstack gap={'small'}>\n  <Tile label={'Max width: 300px'}>\n   <Bar maxWidth={'300px'} />\n  </Tile>\n\n  <Tile label={'Min width: 300px'}>\n   <Bar minWidth={'300px'} />\n   <Bar width={'100%'} />\n  </Tile>\n </vstack>\n);\nimport { Devvit } from '@devvit/public-api';\nimport {\n CategoryPage,\n CategoryProps,\n SharedCategoryPageProps,\n} from '../../components/CategoryPage.js';\nimport BlockComponent = Devvit.BlockComponent;\nimport { SizeConstraintsCategory } from './SizeConstraintsCategory.js';\nimport { SizeAbsoluteCategory } from './SizeAbsoluteCategory.js';\nimport { SizeRelativeCategory } from './SizeRelativeCategory.js';\n\nconst categories: CategoryProps[] = [\n {\n  label: 'Relative',\n  category: 'relative',\n  content: <SizeRelativeCategory />,\n },\n {\n  label: 'Absolute',\n  category: 'absolute',\n  content: <SizeAbsoluteCategory />,\n },\n {\n  label: 'Constraints',\n  category: 'constraints',\n  content: <SizeConstraintsCategory />,\n },\n];\n\nexport const SizePage: BlockComponent<SharedCategoryPageProps> = ({ state }) => (\n <CategoryPage\n  title={'Size'}\n  state={state}\n  categories={categories}\n  activeCategory={state.category}\n  onCategoryChanged={state.setCategory}\n />\n);\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport BlockComponent = Devvit.BlockComponent;\nimport { Bar } from '../../components/Bar.js';\n\nconst ExampleWidth: BlockComponent<{ width: number }> = ({ width }) => (\n <Tile label={`Width ${width}%`}>\n  <vstack gap={'small'} grow>\n   <Bar fillWidth={`${width}%`} />\n   <Bar width={'66%'} fillWidth={`${width}%`} />\n   <Bar width={'33%'} fillWidth={`${width}%`} />\n  </vstack>\n </Tile>\n);\n\nexport const SizeRelativeCategory = () => (\n <>\n  <ExampleWidth width={100} />\n  <ExampleWidth width={66} />\n  <ExampleWidth width={33} />\n </>\n);\nimport { Devvit } from '@devvit/public-api';\n\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { SpacerSizeCategory } from './SpacerSizeCategory.js';\nimport { Page } from '../page.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\nexport const SpacerPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Size',\n   category: 'size',\n   content: <SpacerSizeCategory />,\n  },\n ];\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.SPACERS)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const SpacerSizeCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.SpacerSize][] = [\n  ['XSmall (4 dp)', 'xsmall'],\n  ['Small (8 dp)', 'small'],\n  ['Medium (16 dp)', 'medium'],\n  ['Large (32 dp)', 'large'],\n ];\n\n const content = options.map(([label, size]) => (\n  <Tile label={label}>\n   <hstack\n    border={'thin'}\n    padding={'small'}\n    backgroundColor=\"secondary-background\"\n    height={'48px'}\n    alignment=\"middle\"\n   >\n    <text>A</text>\n    <hstack alignment={'middle'}>\n     <hstack backgroundColor=\"alienblue-500\">\n      <spacer size={size} shape={'thin'} />\n     </hstack>\n    </hstack>\n    <text>B</text>\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { StackAlignmentPreview } from './StackAlignmentPreview.js';\nimport { CategoryPage, CategoryPageState } from '../../components/CategoryPage.js';\n\nexport const StackAlignmentCategory = ({ state }: { state: CategoryPageState }): JSX.Element => {\n const subCategories = [\n  ['Horizontal', 'horizontal'],\n  ['Vertical', 'vertical'],\n  ['Horiz + Vert', 'horizontal vertical'],\n ];\n\n const content = subCategories.map(([label, subcategory]) => ({\n  label,\n  category: subcategory,\n  content: <StackAlignmentPreview mode={subcategory} />,\n }));\n\n return (\n  <CategoryPage\n   state={state}\n   subCategoryPage\n   categories={content}\n   activeCategory={state.subcategory}\n   onCategoryChanged={state.setSubCategory}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Columns } from '../../components/Columns.js';\nimport { Tile } from '../../components/Tile.js';\nimport { Box } from '../../components/Box.js';\nimport Alignment = Devvit.Blocks.Alignment;\n\nconst horizontalAlignment: Devvit.Blocks.Alignment[] = ['start', 'center', 'end'];\nconst verticalAlignment: Devvit.Blocks.Alignment[] = ['top', 'middle', 'bottom'];\n\nexport const StackAlignmentPreview = ({ mode }: { mode: string }): JSX.Element => {\n const options: [string, string][] = [];\n\n if (mode.includes('vertical')) {\n  for (const vert of verticalAlignment) {\n   if (mode.includes('horizontal')) {\n    for (const horiz of horizontalAlignment) {\n     options.push([`${horiz} + ${vert}`, `${horiz} ${vert}`]);\n    }\n   } else {\n    options.push([vert, vert]);\n   }\n  }\n } else if (mode.includes('horizontal')) {\n  for (const horiz of horizontalAlignment) {\n   options.push([horiz, horiz]);\n  }\n }\n\n const content = options.map(([label, style]) => (\n  <Tile label={label} padding=\"small\">\n   <zstack alignment={style as Alignment} backgroundColor=\"#EAEDEF\">\n    <Box size={2} />\n    <Box size={1} color=\"#0045AC\" rounded />\n   </zstack>\n  </Tile>\n ));\n\n return (\n  <vstack grow>\n   <Columns count={3}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\nimport { Box } from '../../components/Box.js';\n\nexport const StackBorderCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ContainerBorderWidth][] = [\n  ['None *', 'none'],\n  ['Thin (1 dp)', 'thin'],\n  ['Thick (2 dp)', 'thick'],\n ];\n\n const content = options.map(([label, option]) => (\n  <Tile label={label}>\n   <hstack backgroundColor=\"secondary-background\" border={option}>\n    <Box />\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Box } from '../../components/Box.js';\nimport { Columns } from '../../components/Columns.js';\n\nconst boxesPerLine: number = 3;\nconst boxes: JSX.Element[] = new Array(boxesPerLine).fill(<Box color=\"rgba(0, 69, 172, 0.5)\" />);\n\nexport const StackDirectionCategory = (): JSX.Element => (\n <Columns count={2}>\n  <Tile label=\"HStack\">\n   <hstack gap=\"small\">{boxes}</hstack>\n  </Tile>\n\n  <Tile label=\"VStack\">\n   <vstack gap=\"small\">{boxes}</vstack>\n  </Tile>\n\n  <Tile label=\"ZStack\">\n   <zstack>{boxes}</zstack>\n  </Tile>\n </Columns>\n);\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\nimport { Box } from '../../components/Box.js';\n\nexport const StackGapCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ContainerGap][] = [\n  ['None *', 'none'],\n  ['Small (8 dp)', 'small'],\n  ['Medium (16 dp)', 'medium'],\n  ['Large (32 dp)', 'large'],\n ];\n\n const boxCount = 3;\n const content = options.map(([label, option]) => (\n  <Tile label={label}>\n   <hstack backgroundColor=\"#EAEDEF\" gap={option}>\n    {new Array(boxCount).fill(<Box color=\"#0045AC\" />)}\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\nimport { Box } from '../../components/Box.js';\n\nexport const StackPaddingCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ContainerPadding][] = [\n  ['None *', 'none'],\n  ['XSmall (4 dp)', 'xsmall'],\n  ['Small (8 dp)', 'small'],\n  ['Medium (16 dp)', 'medium'],\n  ['Large (32 dp)', 'large'],\n ];\n\n const content = options.map(([label, option]) => (\n  <Tile label={label} padding=\"small\">\n   <hstack backgroundColor=\"#0045AC\" padding={option}>\n    <Box color=\"#EAEDEF\" />\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { StackDirectionCategory } from './StackDirectionCategory.js';\nimport { StackRoundingCategory } from './StackRoundingCategory.js';\nimport { StackAlignmentCategory } from './StackAlignmentCategory.js';\nimport { StackGapCategory } from './StackGapCategory.js';\nimport { StackPaddingCategory } from './StackPaddingCategory.js';\nimport { StackBorderCategory } from './StackBorderCategory.js';\nimport { StackReverseCategory } from './StackReverseCategory.js';\nimport { Page } from '../page.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\nexport const StacksPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Direction',\n   category: 'direction',\n   content: <StackDirectionCategory />,\n  },\n  {\n   label: 'Gap',\n   category: 'gap',\n   content: <StackGapCategory />,\n  },\n  {\n   label: 'Padding',\n   category: 'padding',\n   content: <StackPaddingCategory />,\n  },\n  {\n   label: 'Alignment',\n   category: 'alignment',\n   content: <StackAlignmentCategory state={state} />,\n  },\n  {\n   label: 'Corner radius',\n   category: 'rounding',\n   content: <StackRoundingCategory />,\n  },\n  {\n   label: 'Border',\n   category: 'border',\n   content: <StackBorderCategory />,\n  },\n  {\n   label: 'Reverse',\n   category: 'reverse',\n   content: <StackReverseCategory />,\n  },\n ];\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.STACKS)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const StackReverseCategory = (): JSX.Element => {\n const options: [string, boolean][] = [\n  ['False *', false],\n  ['True', true],\n ];\n\n const letters: string[] = ['A', 'B', 'C'];\n\n const content = options.map(([label, option]) => (\n  <Tile label={label}>\n   <hstack reverse={option} gap=\"small\">\n    {letters.map((letter) => (\n     <hstack\n      width={'32px'}\n      height={'32px'}\n      backgroundColor={'#0045ac'}\n      alignment={'middle center'}\n     >\n      <text selectable={false} weight=\"bold\" color=\"#ffffff\">\n       {letter}\n      </text>\n     </hstack>\n    ))}\n   </hstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\nimport { Box } from '../../components/Box.js';\n\nexport const StackRoundingCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.ContainerCornerRadius][] = [\n  ['None *', 'none'],\n  ['Small (8 dp)', 'small'],\n  ['Medium (16 dp)', 'medium'],\n  ['Large (24 dp)', 'large'],\n  ['Full (50%)', 'full'],\n ];\n\n const content = options.map(([label, option]) => (\n  <Tile label={label} padding=\"small\">\n   <vstack backgroundColor=\"#0045AC\" cornerRadius={option}>\n    <Box size={2} />\n   </vstack>\n  </Tile>\n ));\n\n return (\n  <vstack>\n   <Columns count={2}>{content}</Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const TextOutlineCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.Thickness, string][] = [\n  ['None *', 'none', 'bright'],\n  ['Thin', 'thin', 'bright'],\n  ['Thick', 'thick', 'bright'],\n  ['None *', 'none', 'dark'],\n  ['Thin', 'thin', 'dark'],\n  ['Thick', 'thick', 'dark'],\n ];\n\n return (\n  <vstack>\n   <Columns count={3}>\n    {options.map(([label, style, color]) => (\n     <Tile label={label}>\n      <hstack backgroundColor=\"#808080\" padding=\"small\" cornerRadius=\"small\" grow>\n       <text\n        selectable={false}\n        color={color === 'dark' ? 'tone-1' : 'tone-7'}\n        outline={style}\n       >\n        Text\n       </text>\n      </hstack>\n     </Tile>\n    ))}\n   </Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport type { CategoryProps, SharedCategoryPageProps } from '../../components/CategoryPage.js';\nimport { CategoryPage } from '../../components/CategoryPage.js';\nimport { TextSizeCategory } from './TextSizeCategory.js';\nimport { TextWeightCategory } from './TextWeightCategory.js';\nimport { TextOutlineCategory } from './TextOutlineCategory.js';\nimport { TextStyleCategory } from './TextStyleCategory.js';\nimport { Page } from '../page.js';\nimport { StringUtil } from '@devvit/shared-types/StringUtil.js';\n\nexport const TextPage = ({ state }: SharedCategoryPageProps): JSX.Element => {\n const categories: CategoryProps[] = [\n  {\n   label: 'Sizes',\n   category: 'size',\n   content: <TextSizeCategory />,\n  },\n  {\n   label: 'Weights',\n   category: 'weight',\n   content: <TextWeightCategory />,\n  },\n  {\n   label: 'Outline',\n   category: 'outline',\n   content: <TextOutlineCategory />,\n  },\n  {\n   label: 'Styles',\n   category: 'style',\n   content: <TextStyleCategory />,\n  },\n ];\n return (\n  <CategoryPage\n   state={state}\n   categories={categories}\n   activeCategory={state.category}\n   onCategoryChanged={state.setCategory}\n   title={StringUtil.capitalize(Page.TEXT)}\n  />\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const TextSizeCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.TextSize][] = [\n  ['XSmall', 'xsmall'],\n  ['Small', 'small'],\n  ['Medium *', 'medium'],\n  ['Large', 'large'],\n  ['XLarge', 'xlarge'],\n  ['XXLarge', 'xxlarge'],\n ];\n\n return (\n  <vstack>\n   <Columns count={2}>\n    {options.map(([label, value]) => (\n     <Tile label={label}>\n      <text selectable={true} size={value}>\n       The quick brown fox jumps over the lazy dog.\n      </text>\n     </Tile>\n    ))}\n   </Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const TextStyleCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.TextStyle][] = [\n  ['Metadata', 'metadata'],\n  ['Body *', 'body'],\n  ['Heading', 'heading'],\n ];\n\n return (\n  <vstack>\n   <Columns count={1}>\n    {options.map(([label, style]) => (\n     <Tile label={label}>\n      <text selectable={true} style={style}>\n       The quick brown fox jumps over the lazy dog.\n      </text>\n     </Tile>\n    ))}\n   </Columns>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\n\nimport { Tile } from '../../components/Tile.js';\nimport { Columns } from '../../components/Columns.js';\n\nexport const TextWeightCategory = (): JSX.Element => {\n const options: [string, Devvit.Blocks.TextWeight][] = [\n  ['Regular *', 'regular'],\n  ['Semibold', 'bold'],\n ];\n\n return (\n  <vstack>\n   <Columns count={2}>\n    {options.map(([label, style]) => (\n     <Tile label={label}>\n      <text size=\"large\" weight={style}>\n       The quick brown fox jumps over the lazy dog.\n      </text>\n     </Tile>\n    ))}\n   </Columns>\n  </vstack>\n );\n};\nimport { HomePage } from './Home/HomePage.js';\nimport { ButtonPage } from './Button/ButtonPage.js';\nimport { ImagePage } from './Image/ImagePage.js';\nimport { StacksPage } from './Stack/StackPage.js';\nimport { SpacerPage } from './Spacer/SpacerPage.js';\nimport { TextPage } from './Text/TextPage.js';\nimport { IconPage } from './Icon/IconPage.js';\nimport { ColorPage } from './Color/ColorPage.js';\nimport { SizePage } from './Size/SizePage.js';\nimport { Page } from './page.js';\n\nexport {\n HomePage,\n ButtonPage,\n ImagePage,\n StacksPage,\n SpacerPage,\n TextPage,\n IconPage,\n ColorPage,\n SizePage,\n Page,\n};\nexport enum Page {\n HOME = 'home',\n BUTTONS = 'buttons',\n IMAGES = 'images',\n SPACERS = 'spacers',\n STACKS = 'stacks',\n TEXT = 'text',\n ICON = 'icon',\n COLOR = 'color',\n SIZE = 'size',\n}\nimport { ContextAPIClients, UseStateResult } from '@devvit/public-api';\n\nimport { Page } from '../pages/page.js';\nimport { CategoryPageState } from '../components/CategoryPage.js';\n\nexport type StatefulProps = {\n useState: ContextAPIClients['useState'];\n goHome: () => void;\n};\n\nconst PAGES = [\n Page.HOME,\n Page.BUTTONS,\n Page.IMAGES,\n Page.STACKS,\n Page.SPACERS,\n Page.TEXT,\n Page.ICON,\n Page.COLOR,\n Page.SIZE,\n];\n\n/**\n * Override default category for page\n */\nconst DEFAULT_CATEGORY: Record<string, string> = {\n [Page.COLOR]: 'hex',\n};\n\nexport class GalleryState {\n readonly _currentPage: UseStateResult<Page>;\n readonly _pageStates: Record<Page, CategoryPageState>;\n readonly showToast: (message: string) => void;\n\n constructor(renderContext: ContextAPIClients) {\n  const { useState } = renderContext;\n  const goHome = (): void => {\n   this.currentPage = Page.HOME;\n  };\n  const statefulProps: StatefulProps = { useState, goHome };\n  this._currentPage = useState<Page>(Page.HOME);\n\n  this._pageStates = PAGES.reduce(\n   (out, page) => ({\n    ...out,\n    [page]: new CategoryPageState(statefulProps, DEFAULT_CATEGORY[page] ?? ''),\n   }),\n   {} as typeof this._pageStates\n  );\n\n  this.showToast = (message: string) => renderContext.ui.showToast(message);\n }\n\n get currentPage(): Page {\n  return this._currentPage[0];\n }\n\n set currentPage(page: Page | string) {\n  this._currentPage[1](page as Page);\n }\n\n pageState(page: Page): CategoryPageState {\n  return this._pageStates[page];\n }\n}\nimport {Devvit} from '@devvit/public-api'\n\nconst colors = [\n \"#FFFFFF\",\n \"#000000\",\n \"#EB5757\",\n \"#F2994A\",\n \"#F2C94C\",\n \"#27AE60\",\n \"#2F80ED\",\n \"#9B51E0\"\n];\n\nconst resolution = 8;\nconst size = 32;\nconst blankCanvas = new Array(resolution * resolution).fill(0);\nconst defaultColor = 1;\n\nDevvit.addCustomPostType({\n name: 'Name',\n render: context => {\n  const { useState } = context;\n  const [activeColor, setActiveColor] = useState(defaultColor);\n  const [data, setData] = useState(blankCanvas);\n\n  const ColorSelector = () => (\n   <hstack width=\"100%\" alignment=\"center\">\n    {/* nested hstack to negate grow */}\n    <hstack border=\"thin\" grow={false} cornerRadius=\"small\">\n     {colors.map((color, index) => (\n      <hstack\n       height={`${size}px`}\n       width={`${size}px`}\n       backgroundColor={color}\n       onPress={() => setActiveColor(index)}\n       alignment=\"middle center\"\n      >\n       {activeColor === index && (\n        <text\n         color={index === 1 ? \"white\" : \"black\"}\n         weight=\"bold\"\n         size=\"xxlarge\"\n        >\n         ✓\n        </text>\n       )}\n      </hstack>\n     ))}\n    </hstack>\n   </hstack>\n  );\n\n  const pixels = data.map((pixel, index) => (\n   <hstack\n    onPress={() => {\n     const newData = data;\n     newData[index] = activeColor;\n     setData(newData);\n    }}\n    height={`${size}px`}\n    width={`${size}px`}\n    backgroundColor={colors[pixel]}\n   />\n  ));\n\n  const gridSize = `${resolution * size}px`;\n\n  function splitArray<T>(array: T[], segmentLength: number): T[][] {\n   const result: T[][] = [];\n   for (let i = 0; i < array.length; i += segmentLength) {\n    result.push(array.slice(i, i + segmentLength));\n   }\n   return result;\n  }\n   \n  const Canvas = () => (\n   <vstack\n    cornerRadius=\"small\"\n    border=\"thin\"\n    height={gridSize}\n    width={gridSize}\n   >\n    {splitArray(pixels, resolution).map((row) => (\n     <hstack>{row}</hstack>\n    ))}\n   </vstack>\n  );\n   \n  return (\n   <blocks>\n    <vstack gap=\"small\" width=\"100%\" height=\"100%\" alignment=\"center middle\">\n     <Canvas />\n     <ColorSelector />\n    </vstack>\n   </blocks>\n  )\n }\n})\n\nexport default Devvit\nimport {Devvit} from '@devvit/public-api'\n\nfunction getCurrentTime() {\n const now = new Date()\n const hours = String(now.getHours()).padStart(2, '0')\n const minutes = String(now.getMinutes()).padStart(2, '0')\n const seconds = String(now.getSeconds()).padStart(2, '0')\n return `${hours}:${minutes}:${seconds}`\n}\n\nDevvit.addCustomPostType({\n name: 'Clock',\n render: context => {\n  const [time, setTime] = context.useState(() => getCurrentTime())\n  const tick = () => setTime(() => getCurrentTime())\n  context.useInterval(tick, 1000).start()\n\n  return (\n   <vstack alignment='center middle' height='100%'>\n    <text size='xxlarge'>{time}</text>\n   </vstack>\n  )\n }\n})\n\nexport default Devvit\nimport { Devvit } from '@devvit/public-api';\nimport { handleNuke } from './nuke.js';\n\nDevvit.configure({\n redditAPI: true,\n modLog: true,\n});\n\nconst nukeForm = Devvit.createForm(\n () => {\n  return {\n   fields: [\n    {\n     name: 'remove',\n     label: 'Remove comments',\n     type: 'boolean',\n     defaultValue: true,\n    },\n    {\n     name: 'lock',\n     label: 'Lock comments',\n     type: 'boolean',\n     defaultValue: false,\n    },\n    {\n     name: 'skipDistinguished',\n     label: 'Skip distinguished comments',\n     type: 'boolean',\n     defaultValue: false,\n    },\n   ],\n   title: 'Mop Comments',\n   acceptLabel: 'Mop',\n   cancelLabel: 'Cancel',\n  };\n },\n async ({ values }, context) => {\n  if (context.commentId) {\n   const result = await handleNuke(\n    {\n     remove: values.remove,\n     lock: values.lock,\n     skipDistinguished: values.skipDistinguished,\n     commentId: context.commentId,\n     subredditId: context.subredditId,\n    },\n    context\n   );\n   console.log(`Mop result - ${result.success ? 'success' : 'fail'} - ${result.message}`);\n   context.ui.showToast(`${result.success ? 'Success' : 'Failed'} : ${result.message}`);\n  } else {\n   context.ui.showToast(`Mop failed! Please try again later.`);\n  }\n }\n);\n\nDevvit.addMenuItem({\n label: 'Mop comments',\n description: 'Remove this comment and all child comments. This might take a few seconds to run.',\n location: 'comment',\n forUserType: 'moderator',\n onPress: (_, context) => {\n  context.ui.showForm(nukeForm);\n },\n});\n\nexport default Devvit;\nimport { Comment, Devvit } from '@devvit/public-api';\n\nexport type NukeProps = {\n remove: boolean;\n lock: boolean;\n skipDistinguished: boolean;\n commentId: string;\n subredditId: string;\n};\n\nasync function getAllCommentsInThread(\n comment: Comment,\n result: Comment[] = []\n): Promise<Comment[]> {\n result.push(comment);\n const replies = await comment.replies.all();\n // console.log(`added comment - ${comment.id} - ${comment.body} - replies: ${replies.length}`);\n if (replies.length > 0) {\n  for (const reply of replies) {\n   await getAllCommentsInThread(reply, result);\n  }\n }\n return result;\n}\n\nexport async function handleNuke(props: NukeProps, context: Devvit.Context) {\n const startTime = new Date();\n let success = true;\n let message: string;\n\n const shouldLock = props.lock;\n const shouldRemove = props.remove;\n const skipDistinguished = props.skipDistinguished;\n\n if (!shouldLock && !shouldRemove) {\n  return { message: 'You must select either lock or remove.', success: false };\n }\n\n try {\n  const comment = await context.reddit.getCommentById(props.commentId);\n  const user = await context.reddit.getCurrentUser();\n  const modPermissions = await user.getModPermissionsForSubreddit(comment.subredditName);\n  const canManagePosts = modPermissions.includes('all') || modPermissions.includes('posts');\n\n  console.log(\n   `Mod Info: r/${comment.subredditName} u/${user.username} permissions:${modPermissions}: ${\n    canManagePosts ? 'Can mod' : 'Cannot mod'\n   }`\n  );\n\n  if (!canManagePosts) {\n   console.info('A user without the correct mod permissions tried to comment mop.');\n   return {\n    message: 'You do you not have the correct mod permissions to do this.',\n    success: false,\n   };\n  }\n\n  const allComments = await getAllCommentsInThread(comment);\n  const comments = allComments.filter(\n   (eachComment) => !(skipDistinguished && eachComment.isDistinguished())\n  );\n\n  // Build lock and remove promise arrays\n  const lockPromises: Promise<any>[] = [];\n  const removePromises: Promise<any>[] = [];\n\n  for (const eachComment of comments) {\n   const commentId = eachComment.id;\n   if (shouldLock && !eachComment.locked) {\n    console.info(`Locking comment ${commentId}.`);\n    lockPromises.push(eachComment.lock());\n   }\n\n   if (shouldRemove && !eachComment.removed) {\n    console.info(`Removing comment ${commentId}.`);\n    removePromises.push(eachComment.remove());\n   }\n  }\n  const responses = await Promise.all([...removePromises, ...lockPromises]);\n\n  for (const r of responses) {\n   if (r && r.status === 'rejected') {\n    console.error('Failed to remove or lock a comment.');\n    console.info(r.reason);\n   }\n  }\n\n  const verbage =\n   shouldLock && shouldRemove ? 'removed and locked' : shouldLock ? 'locked' : 'removed';\n\n  if (shouldRemove) {\n   const commentId = props.commentId;\n   await context.modLog\n    .add({\n     action: 'removecomment',\n     target: commentId,\n     details: 'comment-mop app',\n     description: `u/${user.username} used comment-mop to ${verbage} this comment and all child comments.`,\n    })\n    .catch((e: any) =>\n     console.error(`Failed to add modlog for comment: ${commentId}.`, e.message)\n    );\n  }\n\n  success = true;\n  message = `${comments.length} comment${\n   comments.length > 1 ? 's' : ''\n  } ${verbage}! Refresh the page to see the cleanup.`;\n\n  // Log out how long the action took to run.\n  const finishTime = new Date();\n  const timeElapsed = (finishTime as any) - (startTime as any);\n  console.info(`${comments.length} comment(s) handled in ${timeElapsed / 1000} seconds.`);\n } catch (err: any) {\n  success = false;\n  message = 'Mop failed! Please try again later.';\n  console.error(`${err.toString()}`);\n }\n\n return { success, message };\n}\nimport {Devvit, } from '@devvit/public-api'\n\ntype PageProps = {\n setPage: (page: string) => void;\n}\n\nconst PageA = ({ setPage }: PageProps) => (\n <vstack\n  width=\"100%\"\n  height=\"100%\"\n  alignment=\"middle center\"\n  gap=\"large\"\n  backgroundColor=\"lightblue\"\n >\n  <text size=\"xxlarge\">Page A</text>\n  <button onPress={() => setPage('b')}>Go to B</button>\n </vstack>\n);\n\nconst PageB = ({ setPage }: PageProps) => (\n <vstack\n  width=\"100%\"\n  height=\"100%\"\n  alignment=\"middle center\"\n  gap=\"large\"\n  backgroundColor=\"pink\"\n >\n  <text size=\"xxlarge\">Page B</text>\n  <button onPress={() => setPage('a')}>Go to A</button>\n </vstack>\n);\n\nDevvit.addCustomPostType({\n name: 'Name',\n render: context => {\n  const { useState } = context;\n  const [page, setPage] = useState('a');\n\n  let currentPage;\n  switch (page) {\n   case 'a':\n    currentPage = <PageA setPage={setPage} />;\n    break;\n   case 'b':\n    currentPage = <PageB setPage={setPage} />;\n    break;\n   default:\n    currentPage = <PageA setPage={setPage} />;\n  }\n\n  return (\n   <blocks>\n    {currentPage}\n   </blocks>\n  )\n }\n})\n\nexport default Devvit\nimport { Devvit } from '@devvit/public-api';\nimport numbroImport from 'numbro';\nconst numbro = numbroImport as unknown as typeof numbroImport.default;\n\nexport const formatCount = (count: number): string => {\n return numbro(count).format({\n  average: true,\n  mantissa: 1,\n  optionalMantissa: true,\n  trimMantissa: true,\n  thousandSeparated: true,\n });\n};\n\nexport function isStringValid(string: string | undefined | null): boolean {\n return string !== null && string !== undefined && string?.trim() !== '';\n}\n\nexport function shuffle<T>(arr: T[]) {\n for (let i = arr.length - 1; i > 0; i--) {\n  const j = Math.floor(Math.random() * (i + 1));\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n}\n\n// Keys and stuff\n\nexport enum KeyType {\n finish = `finish`,\n question = `question`,\n description = `description`,\n options = `options`,\n allowShowResults = `allowShowResults`,\n voted = `voted`,\n randomizeOrder = `randomizeOrder`,\n}\n\nconst undefinedValue = `undefined`;\n\nexport const userKey = (userId: string | undefined, postId: string | undefined): string => {\n return `polls:${postId ?? undefinedValue}:${userId ?? undefinedValue}`;\n};\n\nexport const key = (keyType: KeyType, postId: string | undefined): string => {\n return `polls:${postId ?? undefinedValue}:${keyType}`;\n};\n\n// What does our data look like?\n/*\nInput:\n{\n\tevent {\n\t\tvalues {\n\t\t\tquestion: string (ex. \"What is your choice?\")\n   description: string (ex. \"Choose wisely\")\n   days: int (ex. 7)\n\t\t\tanswers: string (ex. \"option 1, option 2, option 3\")\n   allowShowResults: boolean \n\t\t}\n\t}\n}\n\nData:\n{\n\tpolls {\n\t\tpostId {\n\t\t\tfinish: Timestamp (timestamp in ms, now + duration)\n\t\t\tquestion: String\n\t\t\tanswers: [\n\t\t\t\tanswer: String\n\t\t\t\tscore: Int\n\t\t\t]\n   description: string\n   allowShowResults: boolean as string (ex. \"true\" or \"false\")\n   voted {\n\n   }\n   userId {\n\n   }\n\t\t}\n\t}\n\n}\n*/\n\n/**\n * this only happens in the development environment, where postId is undefined. This is a hack\n * to reset the state of the poll. Also, the debug panel would be available.\n */\nexport const resetRedis = async (context: Devvit.Context): Promise<void> => {\n const redis = context.redis;\n await redis.mset({\n  'polls:undefined:question': 'What is your favorite color?',\n  'polls:undefined:finish': new Date().getTime() + 5 * 60 * 1000 + '',\n  'polls:undefined:0': '0',\n  'polls:undefined:1': '0',\n  'polls:undefined:2': '0',\n });\n const voteds = await redis.zRange(`polls:undefined:voted`, 0, -1);\n if (voteds.length > 0) {\n  await redis.del(...voteds.map((voted) => voted.member));\n }\n await redis.del(`polls:undefined:voted`);\n await redis.zAdd(\n  `polls:undefined:options`,\n  {\n   member: 'Red',\n   score: 0,\n  },\n  {\n   member: 'Green',\n   score: 1,\n  },\n  {\n   member: 'Blue',\n   score: 2,\n  }\n );\n console.log('I reset the state');\n};\n\n// reset userID did vote on iddqd\nDevvit.addTrigger({\n event: 'CommentCreate',\n onEvent: async (event, context) => {\n  if (event.comment?.body === 'iddqd') {\n   const postId = event.post?.id;\n   const redis = context.redis;\n   const userId = event.author?.id;\n   await redis.del(userKey(userId, postId));\n  }\n },\n});\nexport enum PageType {\n VOTE,\n RESULTS,\n CONFIRM,\n}\n\nexport type PollProps = {\n navigate: (page: PageType) => void;\n remainingMillis: number;\n options: string[];\n shuffledOptions: string[];\n optionsPerPollPage: number;\n pollPages: number;\n votes: number[];\n description: string | undefined;\n setVotes: (votes: number[]) => void;\n setFinish: (timestamp: number) => void;\n finish: number;\n total: number;\n allowShowResults: boolean;\n randomizeOrder: boolean;\n reset: () => Promise<void>;\n};\nimport { RedditAPIClient } from '@devvit/public-api';\n\nexport async function sendPM(reddit: RedditAPIClient): Promise<void> {\n const currentUser = await reddit.getCurrentUser();\n await reddit.sendPrivateMessage({\n  to: currentUser.username,\n  subject: 'Thanks for participating!',\n  text: 'Come back later to see the results',\n });\n}\nimport { Devvit } from '@devvit/public-api';\nimport { PageType, PollProps } from '../PollModels.js';\nimport { KeyType, key, userKey } from '../PollHelpers.js';\n\nexport const ConfirmPage: Devvit.BlockComponent<PollProps> = async (\n { votes, setVotes, navigate },\n { redis, userId, postId }\n) => {\n const skipOption = -2;\n const skipVote = async (): Promise<void> => {\n  const user = userKey(userId, postId);\n  const tx = await redis.watch(user);\n  let already = false;\n  try {\n   already = !!(await redis.get(user));\n  } catch {\n   // ignored\n  }\n  await tx.multi();\n  await tx.zAdd(key(KeyType.voted, postId), { member: user, score: 0 });\n  if (already) {\n   await tx.exec();\n  } else {\n   await tx.set(user, skipOption + '');\n   await redis.incrBy(`polls:${postId}:${skipOption}`, 1);\n   await tx.exec();\n   setVotes(votes.map((v, i) => (i === skipOption ? v + 1 : v)));\n  }\n  navigate(PageType.RESULTS);\n };\n\n return (\n  <vstack grow alignment=\"center middle\">\n   <text style=\"heading\">Are you sure?</text>\n   <text style=\"body\">You will not be able to vote after viewing the results.</text>\n   <spacer size=\"medium\" />\n   <hstack gap=\"large\">\n    <button size=\"large\" appearance=\"secondary\" onPress={() => navigate(PageType.VOTE)}>\n     Go back to vote\n    </button>\n    <button size=\"large\" appearance=\"destructive\" onPress={() => skipVote()}>\n     Show me the results!\n    </button>\n   </hstack>\n  </vstack>\n );\n};\nimport { Devvit, ZMember } from '@devvit/public-api';\nimport { key, KeyType } from '../PollHelpers.js';\n\nexport const addPoll = Devvit.createForm(\n {\n  title: 'Add a poll',\n  acceptLabel: 'Post',\n  fields: [\n   {\n    name: 'question',\n    label: 'Question',\n    type: 'string',\n    required: true,\n    helpText: `E.g. What is your favorite color?`,\n   },\n   // Description will be used as post selftext, once that is supported for custom posts\n   // {\n   //  name: `description`,\n   //  label: `Description (Optional)`,\n   //  type: `string`,\n   // },\n   {\n    name: 'answers',\n    label: 'Answers (up to 12 total, use a comma to separate)',\n    type: 'paragraph',\n    required: true,\n    helpText: `E.g. \"Red, Orange, Blue, Mother of Pearl\"`,\n   },\n   {\n    name: 'days',\n    label: 'Days to allow voting',\n    type: 'string',\n    defaultValue: `2`,\n    required: true,\n   },\n   {\n    name: 'randomizeOrder',\n    label: 'Shuffle order of poll options',\n    type: 'boolean',\n    defaultValue: true,\n    helpText: `To reduce bias, options will be presented to the user in a shuffled order.`,\n   },\n   {\n    name: 'allowShowResults',\n    label: 'Include \"Show Results\" option',\n    type: 'boolean',\n    defaultValue: true,\n    helpText: `This allow users to see poll results without voting. Users cannot vote after viewing the results.`,\n   },\n  ],\n },\n async (event, { reddit, subredditId, ui, redis }) => {\n  const sub = await reddit.getSubredditById(subredditId);\n  const answers: ZMember[] = event.values.answers\n   .split(',') // Split int array\n   .filter((answer: string) => answer.trim() !== '') // Remove empty strings\n   .slice(0, 12) // Only include the first 12 answers\n   .map((answer: string, i: number) => ({ member: answer.trim(), score: i }));\n\n  if (answers.length < 2) {\n   ui.showToast({\n    text: 'Post Failed - You must include at least 2 poll options.',\n    appearance: 'neutral',\n   });\n   return;\n  }\n\n  const options = {\n   subredditName: sub.name,\n   title: event.values.question,\n   // text: \"TODO - description/selftext\",\n   preview: (\n    <hstack alignment={'center middle'}>\n     <text>Loading...</text>\n    </hstack>\n   ),\n  };\n  const post = await reddit.submitPost(options);\n\n  const timestamp = new Date().getTime() + parseInt(event.values.days) * 24 * 60 * 60 * 1000;\n  const allowShowResults = event.values.allowShowResults ? 'true' : 'false';\n  const randomizeOrder = event.values.randomizeOrder ? 'true' : 'false';\n\n  await redis.set(key(KeyType.finish, post.id), timestamp + '');\n  await redis.set(key(KeyType.question, post.id), event.values.question);\n  await redis.set(key(KeyType.description, post.id), event.values.description);\n  await redis.zAdd(key(KeyType.options, post.id), ...answers);\n  await redis.set(key(KeyType.allowShowResults, post.id), allowShowResults);\n  await redis.set(key(KeyType.randomizeOrder, post.id), randomizeOrder);\n\n  ui.showToast('Poll created!');\n }\n);\nimport { Devvit } from '@devvit/public-api';\nimport { PageType, PollProps } from '../PollModels.js';\nimport { formatCount } from '../PollHelpers.js';\nimport moment from 'moment';\n\ntype ResultProps = {\n option: string;\n votes: number;\n total: number;\n winner: boolean;\n};\n\nconst PollResult = ({ option, votes, total, winner }: ResultProps): JSX.Element => {\n const percent = Math.max((votes / total) * 100, 0.2);\n\n const nice = formatCount(votes);\n\n const PercentBar = (): JSX.Element | false =>\n  percent >= 0 && (\n   <hstack\n    cornerRadius=\"small\"\n    backgroundColor={winner ? 'upvote-background-disabled' : 'downvote-background-disabled'}\n    width={percent}\n    height={'100%'}\n    alignment={'center middle'}\n   >\n    <vstack>\n     <spacer shape=\"square\" size=\"small\" />\n    </vstack>\n   </hstack>\n  );\n\n if (!option && !votes) {\n  return (\n   <vstack>\n    <text color={'transparent'}>_</text>\n    <hstack border={'thin'} borderColor={'transparent'}>\n     <text color={'transparent'}>_</text>\n    </hstack>\n   </vstack>\n  );\n }\n\n return (\n  <zstack width={'100%'}>\n   <PercentBar />\n   <hstack padding=\"small\" width=\"100%\">\n    <text weight=\"bold\">{nice}</text>\n    <spacer size=\"medium\" />\n    <text grow>{option}</text>\n   </hstack>\n  </zstack>\n );\n};\n\nexport const ResultsPage: Devvit.BlockComponent<PollProps> = async (\n {\n  reset,\n  finish,\n  setFinish,\n  options,\n  optionsPerPollPage,\n  pollPages,\n  votes,\n  total,\n  remainingMillis,\n  navigate,\n },\n { postId, useState }\n) => {\n const remaining = moment.duration(remainingMillis).humanize();\n const max = Math.max(...votes);\n\n const zipped = options.map((option, index) => ({\n  option,\n  votes: votes[index],\n  total,\n  winner: votes[index] === max,\n }));\n zipped.sort((a, b) => b.votes - a.votes);\n const three = 3 * 60 * 1000;\n\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n\n const prevPollPage: Devvit.Blocks.OnPressEventHandler = async () => {\n  if (pollPage > 1) {\n   setPollPage(pollPage - 1);\n  }\n };\n const nextPollPage: Devvit.Blocks.OnPressEventHandler = async () => {\n  if (pollPage < pollPages) {\n   setPollPage(pollPage + 1);\n  }\n };\n\n return (\n  <vstack width=\"100%\" height=\"100%\" padding=\"medium\">\n   {remainingMillis > 0 && (\n    <hstack height=\"15%\" width=\"100%\" alignment=\"middle\">\n     <text style=\"heading\" color=\"green\">\n      Open\n     </text>\n     <text style=\"body\">&nbsp;· {remaining} left</text>\n    </hstack>\n   )}\n   {remainingMillis <= 0 && (\n    <hstack height=\"15%\" width=\"100%\" alignment=\"middle\">\n     <text style=\"heading\">Closed</text>\n     <text style=\"body\">&nbsp;· {formatCount(total)} votes</text>\n    </hstack>\n   )}\n   <spacer size=\"xsmall\" />\n   <hstack border=\"thin\"></hstack>\n\n   <vstack gap=\"small\" grow>\n    <spacer size=\"xsmall\" />\n    {zipped.slice(rangeStart, rangeEnd).map((props) => {\n     return <PollResult {...props} />;\n    })}\n   </vstack>\n\n   <hstack width=\"100%\" height=\"15%\" alignment=\"middle\">\n    {pollPages > 1 && (\n     <hstack grow gap=\"medium\" alignment=\"middle\">\n      <button\n       size=\"small\"\n       icon=\"back-outline\"\n       onPress={prevPollPage}\n       disabled={pollPage === 1}\n      />\n      <text>\n       Page {pollPage} of {pollPages}\n      </text>\n      <button\n       size=\"small\"\n       icon=\"forward-outline\"\n       onPress={nextPollPage}\n       disabled={pollPage === pollPages}\n      />\n     </hstack>\n    )}\n   </hstack>\n\n   {!postId && ( // i.e. only in development mode.\n    <vstack gap=\"medium\">\n     <text>Local debug panel</text>\n     <hstack gap=\"medium\">\n      <button\n       onPress={async () => {\n        await reset();\n        navigate(PageType.VOTE);\n       }}\n      >\n       Reset\n      </button>\n      <button onPress={() => navigate(PageType.VOTE)}>Vote again</button>\n      <button onPress={() => setFinish(finish + three)}>+3 minutes</button>\n      <button onPress={() => setFinish(finish - three)}>-3 minutes</button>\n     </hstack>\n    </vstack>\n   )}\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\nimport { PageType, PollProps } from '../PollModels.js';\nimport { KeyType, key, userKey } from '../PollHelpers.js';\nimport moment from 'moment';\n\n// const props = { option, index, selectedOption, setSelectedOption }\nexport const PollOption = ({\n option,\n index,\n selectedOption,\n setSelectedOption,\n}: {\n option: string;\n index: number;\n selectedOption: number;\n setSelectedOption: (n: number) => void;\n}): JSX.Element => {\n const selectOption = (): void => setSelectedOption(index);\n const selected = index === selectedOption;\n return (\n  <vstack>\n   <spacer size=\"small\" />\n   <hstack\n    width=\"100%\"\n    alignment={'start middle'}\n    onPress={selectOption}\n    gap={'small'}\n    data-selection={index}\n   >\n    <icon name={selected ? 'radio-button-fill' : 'radio-button-outline'} />\n    <text grow>{option}</text>\n   </hstack>\n  </vstack>\n );\n};\n\nexport const VotePage: Devvit.BlockComponent<PollProps> = async (\n {\n  options,\n  shuffledOptions,\n  votes,\n  setVotes,\n  navigate,\n  optionsPerPollPage,\n  pollPages,\n  remainingMillis,\n  allowShowResults,\n  randomizeOrder,\n },\n { redis, useState, userId, postId }\n) => {\n const remaining = moment.duration(remainingMillis).humanize();\n const [selectedOption, setSelectedOption] = useState(-1);\n const presentedOptions = randomizeOrder ? shuffledOptions : options;\n\n const submitVote: Devvit.Blocks.OnPressEventHandler = async () => {\n  const user = userKey(userId, postId);\n  const tx = await redis.watch(user);\n  const selectedOptionString = presentedOptions[selectedOption];\n  const optionIndex = options.indexOf(selectedOptionString);\n\n  let already = false;\n  try {\n   already = !!(await redis.get(user));\n  } catch {\n   // ignored\n  }\n  await tx.multi();\n  await tx.zAdd(key(KeyType.voted, postId), { member: user, score: 0 });\n  if (already) {\n   await tx.exec();\n  } else {\n   await tx.set(user, optionIndex + '');\n   await redis.incrBy(`polls:${postId}:${optionIndex}`, 1);\n   await tx.exec();\n   setVotes(votes.map((v, i) => (i === optionIndex ? v + 1 : v)));\n  }\n  navigate(PageType.RESULTS);\n };\n\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n const prevPollPage: Devvit.Blocks.OnPressEventHandler = async () => {\n  if (pollPage > 1) {\n   setPollPage(pollPage - 1);\n  }\n };\n const nextPollPage: Devvit.Blocks.OnPressEventHandler = async () => {\n  if (pollPage < pollPages) {\n   setPollPage(pollPage + 1);\n  }\n };\n\n return (\n  <vstack height=\"100%\" width=\"100%\" padding=\"medium\">\n   <hstack height=\"15%\" width=\"100%\" alignment=\"middle\">\n    <text style=\"heading\" color=\"green\">\n     Open\n    </text>\n    <text style=\"body\">&nbsp;· {remaining} left</text>\n    <spacer grow />\n    {\n     allowShowResults && (\n      <button appearance=\"plain\" onPress={() => navigate(PageType.CONFIRM)}>\n       View Results\n      </button>\n     )\n     // <><text color='alienblue-500' onPress={() => navigate(PageType.CONFIRM)}>View Results</text></>\n    }\n   </hstack>\n   <spacer size=\"xsmall\" />\n   <hstack border=\"thin\"></hstack>\n   <vstack grow>\n    <spacer size=\"small\" />\n    <vstack gap=\"medium\">\n     {presentedOptions.slice(rangeStart, rangeEnd).map((option, index) => {\n      const props = {\n       option,\n       index: index + rangeStart,\n       selectedOption,\n       setSelectedOption,\n      };\n      return <PollOption {...props} />;\n     })}\n    </vstack>\n   </vstack>\n   <hstack width=\"100%\" height=\"15%\" alignment=\"middle\">\n    {pollPages > 1 && (\n     <hstack grow gap=\"medium\" alignment=\"middle\">\n      <button\n       size=\"small\"\n       icon=\"back-outline\"\n       onPress={prevPollPage}\n       disabled={pollPage === 1}\n      />\n      <text>\n       Page {pollPage} of {pollPages}\n      </text>\n      <button\n       size=\"small\"\n       icon=\"forward-outline\"\n       onPress={nextPollPage}\n       disabled={pollPage === pollPages}\n      />\n     </hstack>\n    )}\n    <spacer grow />\n    <button\n     size=\"medium\"\n     appearance=\"primary\"\n     onPress={submitVote}\n     disabled={selectedOption === -1}\n    >\n     Vote!\n    </button>\n   </hstack>\n  </vstack>\n );\n};\nimport { Devvit } from '@devvit/public-api';\nimport { VotePage } from './components/VotePage.js';\nimport { ResultsPage } from './components/ResultsPage.js';\nimport { PageType, PollProps } from './PollModels.js';\nimport { addPoll } from './components/CreatePoll.js';\nimport { KeyType, key, userKey, resetRedis, shuffle } from './PollHelpers.js';\nimport { ConfirmPage } from './components/ConfirmPage.js';\n\n// Devvit.debug.emitSnapshots = true;\n\nDevvit.configure({\n redis: true,\n redditAPI: true,\n});\n\nconst App: Devvit.CustomPostComponent = async (context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n\n const [page, navigate] = useState(async () => {\n  let hasVoted = false;\n  try {\n   hasVoted = !!(await redis.get(userKey(userId, postId)));\n  } catch {\n   //\n  }\n  return hasVoted ? PageType.RESULTS : PageType.VOTE;\n });\n\n useState(async () => {\n  if (postId) return;\n\n  // Load fixture data in dev mode.\n  if (!(await redis.get(key(KeyType.question, `undefined`)))) {\n   await resetRedis(context);\n  }\n });\n\n const [currentUserId] = useState(userId);\n\n const [options] = useState(async () => {\n  const options = await redis.zRange(key(KeyType.options, postId), 0, -1);\n  return options.map((option) => option.member);\n });\n\n const [shuffledOptions] = useState(async () => {\n  const array = [...options];\n  shuffle(array);\n  return array;\n });\n\n const [votes, setVotes] = useState(async () => {\n  const rsp = await redis.mget(options.map((_option, i) => `polls:${postId}:${i}`));\n  return rsp.map((count) => parseInt(count || '0'));\n });\n\n /* Want to know how many skips? ¯\\_(ツ)_/¯\n const [skips, setSkips] = useState(async () => {\n  return await redis.get(`polls:${postId}:${-2}`);\n });\n console.log(`skips - ${skips}`)\n */\n\n const reset = async (): Promise<void> => {\n  await resetRedis(context);\n  setVotes([0, 0, 0]);\n  setFinish(new Date().getTime() + 5 * 60 * 1000);\n };\n\n const total = votes.reduce((a, b) => a + b, 0);\n\n const now = new Date().getTime();\n const [finish, setFinish] = useState(async () => {\n  const finish = await redis.get(key(KeyType.finish, postId));\n  return parseInt(finish || '0');\n });\n const remainingMillis = finish - now;\n\n const [description, _setDescription] = useState(async () => {\n  return await redis.get(key(KeyType.description, postId));\n });\n\n const [allowShowResults, _setAllowShowResults] = useState(async () => {\n  const allow = await redis.get(key(KeyType.allowShowResults, postId));\n  return allow === 'true';\n });\n\n const [randomizeOrder, _setRandomizeOrder] = useState(async () => {\n  const randomize = await redis.get(key(KeyType.randomizeOrder, postId));\n  return randomize === 'true';\n });\n\n const optionsPerPollPage = 4;\n const pollPages = Math.ceil(options.length / optionsPerPollPage);\n\n const props: PollProps = {\n  navigate,\n  options,\n  shuffledOptions,\n  optionsPerPollPage,\n  pollPages,\n  setFinish,\n  votes,\n  description,\n  finish,\n  total,\n  setVotes,\n  remainingMillis,\n  allowShowResults,\n  randomizeOrder,\n  reset,\n };\n\n if (!currentUserId) {\n  return (\n   <hstack grow alignment={'center middle'}>\n    <text>Not logged in</text>\n   </hstack>\n  );\n } else if (page === PageType.VOTE && remainingMillis > 0) {\n  return <VotePage {...props} />;\n } else if (page === PageType.CONFIRM && remainingMillis > 0) {\n  return <ConfirmPage {...props} />;\n } else {\n  return <ResultsPage {...props} />;\n }\n};\n\nDevvit.addMenuItem({\n label: 'Create a new poll (Internal)',\n location: 'subreddit',\n onPress: (_event, context) => {\n  context.ui.showForm(addPoll);\n },\n});\n\nDevvit.addCustomPostType({\n name: 'Polls Plus',\n description: 'Polls but better',\n render: App,\n});\n\nexport default Devvit;\nimport {Devvit} from '@devvit/public-api'\n\nDevvit.addCustomPostType({\n name: 'Progress bar example',\n render: context => {\n  const [progress, setProgress] = context.useState(30)\n  return (\n   <vstack\n    alignment='center middle'\n    height='100%'\n    gap='medium'\n    padding='large'\n   >\n    <vstack backgroundColor='#FFD5C6' cornerRadius='full' width='100%'>\n     <hstack backgroundColor='#D93A00' width={`${progress}%`}>\n      <spacer size='medium' shape='square' />\n     </hstack>\n    </vstack>\n    <hstack gap='medium' width='100%'>\n     <button\n      icon='subtract-fill'\n      width='50%'\n      onPress={() => setProgress(progress => Math.max(progress - 10, 0))}\n     />\n     <button\n      icon='add-fill'\n      width='50%'\n      onPress={() =>\n       setProgress(progress => Math.min(progress + 10, 100))\n      }\n     />\n    </hstack>\n   </vstack>\n  )\n }\n})\n\nexport default Devvit\n// Run me with `npm test`.\ntest('hello test', () => {\n expect(true).toBeTruthy();\n});\n\n// Add more tests here or make a new file named `<subject under test>.test.ts`.\nimport { Devvit, FormOnSubmitEvent } from '@devvit/public-api';\nimport * as chrono from 'chrono-node';\n\nconst REMIND_ME_JOB = 'remindmejob';\n\nDevvit.configure({\n redditAPI: true, // Enable access to the Reddit API\n});\n\nDevvit.addMenuItem({\n label: 'Remind me later',\n location: 'post',\n onPress: async (event, context) => {\n  // Gather user input\n  context.ui.showForm(remindMeForm);\n  const today = new Date();\n  const tomorrow = new Date(today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  await context.scheduler.runJob({\n   name: REMIND_ME_JOB,\n   data: {\n    userId: context.userId,\n    postId: event.targetId,\n   },\n   runAt: tomorrow,\n  });\n },\n});\n\n// Define a job that can be scheduled\nDevvit.addSchedulerJob({\n name: REMIND_ME_JOB,\n onRun: async (event, context) => {\n  const { userId, postId, fromWhen } = event.data!;\n\n  const user = await context.reddit.getUserById(userId);\n  const post = await context.reddit.getPostById(postId);\n\n  await context.reddit.sendPrivateMessage({\n   to: user.username,\n   subject: 'RemindMe',\n   text: `Beep boop! You asked me to remind you about [${post.title}](${post.permalink}) at ${fromWhen}!`,\n  });\n },\n});\n\n// Define a form that will ask the user when to remind them\nconst remindMeForm = Devvit.createForm(\n {\n  fields: [{ name: 'when', label: 'When?', type: 'string' }],\n  title: 'Remind me',\n  acceptLabel: 'Schedule',\n },\n remindMeHandler\n);\n\nasync function remindMeHandler(event: FormOnSubmitEvent, context: Devvit.Context): Promise<void> {\n const whenStr = (event.values.when as string) || '';\n if (!whenStr) {\n  context.ui.showToast(\"I don't know when to remind you!\");\n  return;\n }\n\n const parsedTime = chrono.parseDate(whenStr);\n const now = new Date();\n\n if (parsedTime < now) {\n  context.ui.showToast(\"I can't remind you in the past!\");\n  return;\n }\n const currentUser = await context.reddit.getCurrentUser();\n\n // Schedule a job to run at the given time\n await context.scheduler.runJob({\n  name: REMIND_ME_JOB,\n  data: {\n   userId: currentUser.id,\n   postId: context.postId,\n   fromWhen: now,\n  },\n  runAt: parsedTime,\n });\n\n context.ui.showToast(`Gotcha! I'll send you a message about this post at ${parsedTime}!`);\n}\n\nexport default Devvit;\n// Run me with `npm test`.\ntest('hello test', () => {\n expect(true).toBeTruthy();\n});\n\n// Add more tests here or make a new file named `<subject under test>.test.ts`.\nimport { Comment, Devvit, MenuItemOnPressEvent, Post, User } from '@devvit/public-api';\n\nDevvit.configure({\n redis: true, // Enable access to Redis\n redditAPI: true, // Enable access to Reddit API\n});\n\nDevvit.addMenuItem({\n label: 'Remove and Strike',\n location: ['post', 'comment'],\n forUserType: 'moderator',\n onPress: strike,\n});\n\nDevvit.addMenuItem({\n label: `Check User's Strikes`,\n location: ['post', 'comment'],\n forUserType: 'moderator',\n onPress: checkStrikes,\n});\n\nDevvit.addMenuItem({\n label: 'Remove Strike from Author',\n location: ['post', 'comment'],\n forUserType: 'moderator',\n onPress: removeStrike,\n});\n\nDevvit.addMenuItem({\n label: 'Remove All Strikes from Author',\n location: ['post', 'comment'],\n forUserType: 'moderator',\n onPress: clearStrikes,\n});\n\nasync function getThing(\n event: MenuItemOnPressEvent,\n context: Devvit.Context\n): Promise<Post | Comment> {\n const { location, targetId } = event;\n const { reddit } = context;\n if (location === 'post') {\n  return await reddit.getPostById(targetId);\n } else if (location === 'comment') {\n  return await reddit.getCommentById(targetId);\n }\n throw 'Cannot find a post or comment with that ID';\n}\n\nasync function getAuthor(event: MenuItemOnPressEvent, context: Devvit.Context): Promise<User> {\n const { reddit } = context;\n const thing = await getThing(event, context);\n return await reddit.getUserById(thing.authorId!);\n}\n\n/**\n * Handles the 'strike' action\n */\nasync function strike(event: MenuItemOnPressEvent, context: Devvit.Context): Promise<void> {\n // Use the correct term in our message based on what was acted upon\n const { location } = event;\n const { reddit, ui } = context;\n const thing = await getThing(event, context);\n const author = await getAuthor(event, context);\n\n // Remove the content\n await thing!.remove();\n\n // Add a strike to the user and persist it to Redis\n let strikes = await getAuthorStrikes(author, context);\n await setAuthorStrikes(author, ++strikes, context);\n\n // What we'll send the user in a private message\n let pmMessage = '';\n // Used to tell the moderator what punishment the user received\n let punishment = '';\n // Ban if they're on their 2nd or 3rd strike\n let ban = true;\n // We'll determine how long the ban lasts based on how many strikes they have\n let days = 0;\n\n // Get the current subreddit from the metadata\n const subreddit = await reddit.getCurrentSubreddit();\n const { permalink } = thing;\n switch (strikes) {\n  case 1:\n   // first strike, send a warning\n   pmMessage = `You have received a strike and your ${location} has been removed from ${subreddit.name} for breaking the rules. Another strike will result in a 1-day ban.\\n\\n${permalink}`;\n   punishment = `sent a warning`;\n   ban = false;\n   break;\n  case 2:\n   // second strike, temp ban, warn again\n   days = 1;\n   pmMessage = `You have received your second strike and your ${location} has been removed from ${subreddit.name} and you have been banned for 1 day for breaking the rules.\\n\\nONE MORE STRIKE WILL RESULT IN A 1-YEAR BAN FROM THIS SUBREDDIT.\\n\\n${permalink}`;\n   punishment = `banned for 1 day`;\n   break;\n  case 3:\n  default:\n   // third (and any subsequent strikes), ban for 1 year from now\n   days = 365;\n   pmMessage = `You have been banned from ${subreddit.name} for one year for receiving ${strikes} strikes for your ${location}.\\n\\n${permalink}`;\n   punishment = `banned for 1 year`;\n   break;\n }\n\n // Send a private message to the user\n await reddit.sendPrivateMessage({\n  to: author.username,\n  subject: `Received a strike on ${subreddit.name}`,\n  text: pmMessage,\n });\n\n const result = `u/${author.username} strikes: ${strikes} and has been ${punishment}.`;\n\n if (ban) {\n  const currentUser = await reddit.getCurrentUser();\n  await reddit.banUser({\n   subredditName: subreddit.name,\n   username: author.username,\n   duration: days,\n   context: thing!.id,\n   reason: `Received ${strikes} strike${strikes !== 1 ? 's' : ''} for breaking subreddit rules`,\n   note: `Strike added by ${currentUser.username}`,\n  });\n }\n\n ui.showToast(result);\n}\n\nasync function checkStrikes(event: MenuItemOnPressEvent, context: Devvit.Context): Promise<void> {\n const author = await getAuthor(event, context);\n console.log('checking for ', author.username);\n const { ui } = context;\n const strikes = await getAuthorStrikes(author, context);\n console.log('strikes are ', strikes);\n ui.showToast(`Author u/${author.username} has ${strikes} strike${strikes !== 1 ? 's' : ''}.`);\n}\n\n/**\n * Handles the 'removestrike' action\n */\nasync function removeStrike(event: MenuItemOnPressEvent, context: Devvit.Context): Promise<void> {\n // Get some relevant data from the post or comment\n const author = await getAuthor(event, context);\n const { ui } = context;\n let strikes = await getAuthorStrikes(author, context);\n\n if (strikes > 0) {\n  await setAuthorStrikes(author, --strikes, context);\n  ui.showToast(`Removed a strike from u/${author.username}. Remaining strikes: ${strikes}.`);\n  return;\n }\n\n ui.showToast(`u/${author.username} does not have any strikes!`);\n}\n\n/**\n * Handles the 'clearstrikes' action\n */\nasync function clearStrikes(event: MenuItemOnPressEvent, context: Devvit.Context): Promise<void> {\n // Get some relevant data from the post or comment\n const author = await getAuthor(event, context);\n const hadStrikes = await getAuthorStrikes(author, context);\n const { ui } = context;\n\n if (hadStrikes > 0) {\n  await setAuthorStrikes(author!, 0, context);\n  ui.showToast(\n   `Cleared ${hadStrikes} strike${hadStrikes !== 1 ? 's' : ''} from u/${author.username}!`\n  );\n  return;\n }\n\n ui.showToast(`u/${author.username} does not have any strikes!`);\n}\n\n/**\n * Creates a Redis key for the author\n */\nfunction getKeyForAuthor(author: User): string {\n return `${author.id}_strikes`;\n}\n\n/**\n * Fetch the current strike count for the author\n */\nasync function getAuthorStrikes(author: User, context: Devvit.Context): Promise<number> {\n const { redis } = context;\n const key = getKeyForAuthor(author);\n return ((await redis.get(key)) || 0) as number;\n}\n\n/**\n * Updates the strike counter in Redis\n */\nasync function setAuthorStrikes(\n author: User,\n strikes: number,\n context: Devvit.Context\n): Promise<void> {\n const { redis } = context;\n const key = getKeyForAuthor(author);\n await redis.set(key, strikes.toString());\n}\n\nexport default Devvit;\n\n",
  }];