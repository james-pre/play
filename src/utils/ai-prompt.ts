export const context = [
    {text: "I want to create code using a new API called Devvit. I'm going to provide some sample code in Typescript. When writing code in devvit keep the following in mind: 1) devvit is similar to react, but it is not react. React code will not work in devvit.  2) It is good practice to break code into reusable components.\n\nThe following content is all open-source and subject to the BSD license. This means that copying, reprinting, reciting and reusing the code below is OK.\n\nThis is a simple hello world program written in devvit.\n\n// src/main.tsx\nDevvit.configure({\n redditAPI: true\n});\nDevvit.addCustomPostType({\n name: \"Hello Blocks\",\n initialState: async ({ reddit }) => {\n   const currentUser = await reddit.getCurrentUser();\n   return {\n     username: currentUser.username,\n     counter: 0\n   };\n },\n render: ({ state }) => {\n   return /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"medium\", gap: \"medium\", backgroundColor: \"#FFBEA6\", cornerRadius: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", size: \"xxlarge\" }, \"Hello, \", state.username ?? \"stranger\", \"! \\u{1F44B}\"), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"large\" }, `Click counter: ${state.counter}`), /* @__PURE__ */ Devvit.createElement(\n     \"button\",\n     {\n       onPress: () => {\n         state.counter += 1;\n         console.log(`I am counter ${state.counter}`);\n       }\n     },\n     \"Click me!\"\n   ));\n }\n});\nvar main_default = Devvit;\n\nHere is a more complex example that implements a game called chess puzzles. In it a player is presented with a starting chess position and is asked to find checkmate within a certain number of moves. This extends on the above example in a few ways:\n1) It includes several good examples of how to create reusable components like a leaderboard.\n2) There are several files that are indicated by comments like // src/types.tsx and // src/utilities.tsx. 3) This also makes use of an external npm package, chess.js, which is an open-source chess program whose source code is not included, but which API can be found here: https://github.com/jhlywa/chess.js/blob/master/README.md.\n4) it uses forms to collect user input\n5) it uses devvit's redis-like storage so that data like individual player scores can be persisted. Note that Devvit's redis is not a complete implementation of redis, so not all redis commands will work.\n\n// src/types.tsx\nvar BlankSquare = \"\";\nvar SquareSizeInt = 31;\nvar SquareSizeStr = `${SquareSizeInt}px`;\nvar HighlightSize = `${SquareSizeInt - 10}px`;\nvar DefaultCounter = 6e4;\n\n// src/utilities.tsx\nvar cols = \"abcdefgh\";\nvar rows = \"87654321\";\nfunction getRowColFromSquare(lan, side) {\n const olan = lan;\n if (lan.length === 3) {\n  lan = lan.substring(1);\n }\n const r = rows.indexOf(lan[1]);\n if (r === -1) {\n  console.error(`***** Row is -1. ${olan}`);\n }\n const c = cols.indexOf(lan[0]);\n if (side && side === \"b\" /* black */) {\n  return { row: Math.abs(r - 7), column: Math.abs(c - 7) };\n } else {\n  return { row: r, column: c };\n }\n}\nfunction getSquare(row, column, side) {\n if (side && side === \"b\" /* black */) {\n  return `${cols[Math.abs(column - 7)]}${rows[Math.abs(row - 7)]}`;\n }\n return `${cols[column]}${rows[row]}`;\n}\nfunction pieceToImage(piece) {\n if (piece === \" \" /* BLANK */) {\n  return \"blank.png\";\n } else if (\"PBNQKR\" /* white */.includes(piece)) {\n  return `w${piece}_og.png`;\n } else {\n  return `${piece}_og.png`;\n }\n}\nfunction isMyPiece(turn, piece) {\n return turn === \"w\" /* white */ && \"PBNQKR\" /* white */.includes(piece) || turn === \"b\" /* black */ && \"prbqkn\" /* black */.includes(piece);\n}\nvar undefinedValue = `undefined`;\nvar quizKey = (keyType, postId) => {\n return `chessQuiz:${postId ?? undefinedValue}:${keyType}`;\n};\nvar userKey = (userId, postId, keyType) => {\n if (keyType) {\n  return `chessQuiz:${postId ?? undefinedValue}:${userId ?? undefinedValue}:${keyType}`;\n }\n return `chessQuiz:${postId ?? undefinedValue}:${userId ?? undefinedValue}`;\n};\nvar userStatsKey = (userId, keyType) => {\n return `chessQuiz:stats:${userId ?? undefinedValue}:${keyType}`;\n};\nvar DEFAULT_POINTS = 1;\nfunction parseSanToTurns(sanString) {\n const turns = [];\n const moves = sanString.split(/\\s+/);\n let turnNumber = 1;\n let whiteMove, blackMove;\n let lastMoveWasBlack = false;\n for (let i = 0; i < moves.length; i++) {\n  const move = moves[i];\n  if (move.match(/^\\d+\\.\\.\\.$/)) {\n   turnNumber = parseInt(move, 10);\n   lastMoveWasBlack = false;\n   continue;\n  }\n  if (move.match(/^\\d+\\.$/)) {\n   if (lastMoveWasBlack) {\n    turns.push({ turnNumber, whiteMove, blackMove });\n    whiteMove = void 0;\n    blackMove = void 0;\n   }\n   turnNumber = parseInt(move, 10);\n   lastMoveWasBlack = true;\n   continue;\n  }\n  if (move === \"...\") {\n   if (!lastMoveWasBlack) {\n    throw new Error(`Unexpected ellipses after white move on turn ${turnNumber}`);\n   }\n   lastMoveWasBlack = false;\n   continue;\n  }\n  if (lastMoveWasBlack) {\n   whiteMove = move;\n   lastMoveWasBlack = false;\n  } else {\n   blackMove = move;\n   lastMoveWasBlack = true;\n   continue;\n  }\n }\n if (turnNumber && (whiteMove || blackMove)) {\n  turns.push({ turnNumber, whiteMove, blackMove });\n }\n return turns;\n}\nfunction downgradeBonus(bonus) {\n switch (bonus) {\n  case \"gold\" /* gold */:\n   return \"silver\" /* silver */;\n  case \"silver\" /* silver */:\n   return \"bronze\" /* bronze */;\n  default:\n   return \"none\" /* none */;\n }\n}\nvar BonusImages = {\n [\"gold\" /* gold */]: `icon-rank-1.png`,\n [\"silver\" /* silver */]: `icon-rank-2.png`,\n [\"bronze\" /* bronze */]: `icon-rank-3.png`,\n [\"none\" /* none */]: `success_badge.png`,\n [\"undefined\" /* undefined */]: `unknown_badge.gif`,\n [\"fail\" /* fail */]: `fail_badge.png`\n};\nvar BonusValues = {\n [\"gold\" /* gold */]: 4,\n [\"silver\" /* silver */]: 2,\n [\"bronze\" /* bronze */]: 1,\n [\"none\" /* none */]: 0,\n [\"undefined\" /* undefined */]: 0,\n [\"fail\" /* fail */]: 0\n};\n\n// src/components/InteractiveChessSquare.tsx\nvar InteractiveChessSquare = ({\n row,\n column,\n piece,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}, _context) => {\n const h = highlights.filter((h2) => {\n  return h2.row === row && h2.column === column;\n });\n const isSelected = h?.find((x) => x.type === 0 /* selected */);\n const isMove = h?.find((x) => x.type === 1 /* move */);\n const isSuccess = h?.find((x) => x.type === 4 /* success */);\n const isFail = h?.find((x) => x.type === 5 /* fail */);\n const isOpponentMove = h?.find((x) => x.type === 3 /* opponentMove */);\n const squareColor = (row + column) % 2 === 0 ? \"#F2E1C3\" /* light */ : \"#C3A082\" /* dark */;\n const isMine = isMyPiece(turn, piece);\n return /* @__PURE__ */ Devvit.createElement(\n  \"zstack\",\n  {\n   alignment: \"center middle\",\n   backgroundColor: isSuccess ? \"#55BD46\" /* success */ : isFail ? \"rgba(255,69,0,.7)\" /* fail */ : squareColor,\n   border: \"thick\",\n   borderColor: isSuccess ? \"#55BD46\" /* success */ : isFail ? \"rgba(255,69,0,.7)\" /* fail */ : isSelected ? \"black\" /* selected */ : squareColor,\n   onPress: async () => {\n    if (!(isMine || isMove || piece !== \" \" /* BLANK */))\n     return;\n    if (isMove) {\n     await makeMove(isMove.san);\n    } else if (isSelected) {\n     setHighlights(\n      highlights.filter((h2) => {\n       return !(h2.type === 0 /* selected */ || h2.type === 1 /* move */);\n      })\n     );\n     setActiveSquare(BlankSquare);\n    } else {\n     const newHighlights = highlights.filter((h2) => {\n      return !(h2.type === 0 /* selected */ || h2.type === 1 /* move */);\n     });\n     setHighlights([...newHighlights, { row, column, type: 0 /* selected */ }]);\n     setActiveSquare(getSquare(row, column, turn));\n    }\n   },\n   padding: \"none\",\n   gap: \"none\"\n  },\n  isOpponentMove ? /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    backgroundColor: \"rgba(255,255,0,.72)\" /* opponentMove */,\n    width: SquareSizeStr,\n    height: SquareSizeStr,\n    border: \"thick\",\n    borderColor: \"rgba(255,255,0,.72)\" /* opponentMove */\n   }\n  ) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null),\n  /* @__PURE__ */ Devvit.createElement(\"image\", { url: pieceToImage(piece), imageWidth: SquareSizeInt, imageHeight: SquareSizeInt, resizeMode: \"fit\" }),\n  isFail && isFail.imgUrl ? /* @__PURE__ */ Devvit.createElement(\"image\", { url: isFail.imgUrl, imageWidth: SquareSizeInt, imageHeight: SquareSizeInt }) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null),\n  isMove ? /* @__PURE__ */ Devvit.createElement(\"vstack\", { cornerRadius: \"full\", backgroundColor: \"rgba(255,255,0,.8)\" /* move */, width: HighlightSize, height: HighlightSize }) : /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null)\n );\n};\n\n// src/components/InteractiveChessBoard.tsx\nvar InteractiveChessBoard = ({\n FEN,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}) => {\n const rows2 = parseFEN({\n  FEN,\n  turn,\n  highlights,\n  setHighlights,\n  setActiveSquare,\n  makeMove\n });\n let board;\n if (turn === \"w\" /* white */) {\n  board = rows2.map((row) => {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", null, row);\n  });\n } else {\n  board = rows2.map((row) => {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", null, row.reverse());\n  }).reverse();\n }\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"center middle\" }, board);\n};\nfunction parseFEN({\n FEN,\n turn,\n highlights,\n setHighlights,\n setActiveSquare,\n makeMove\n}) {\n const positions = FEN.split(\" \")[0];\n const rows2 = [];\n let curRow = [];\n let row = 0, column = 0;\n for (let i = 0; i < positions.length; i++) {\n  const p = positions[i];\n  const pInt = Number(p);\n  if (Number(pInt)) {\n   curRow = curRow.concat(\n    Array.from(Array(Number(pInt)), (_, index) => {\n     const displayRow = turn === \"w\" /* white */ ? row : Math.abs(row - 7);\n     const displayColumn = turn === \"w\" /* white */ ? column + index : Math.abs(column + index - 7);\n     return /* @__PURE__ */ Devvit.createElement(\n      InteractiveChessSquare,\n      {\n       row: displayRow,\n       column: displayColumn,\n       piece: \" \" /* BLANK */,\n       turn,\n       highlights,\n       setHighlights,\n       setActiveSquare,\n       makeMove\n      }\n     );\n    })\n   );\n   column += pInt;\n  } else if (p === \"/\") {\n   rows2.push(curRow);\n   row++;\n   column = 0;\n   curRow = [];\n  } else {\n   const displayRow = turn === \"w\" /* white */ ? row : Math.abs(row - 7);\n   const displayColumn = turn === \"w\" /* white */ ? column : Math.abs(column - 7);\n   curRow.push(\n    /* @__PURE__ */ Devvit.createElement(\n     InteractiveChessSquare,\n     {\n      row: displayRow,\n      column: displayColumn,\n      piece: p,\n      turn,\n      highlights,\n      setHighlights,\n      setActiveSquare,\n      makeMove\n     }\n    )\n   );\n   column++;\n  }\n }\n rows2.push(curRow);\n return rows2;\n}\n\n// src/components/Leaderboard.tsx\nvar Leaderboard = class _Leaderboard {\n constructor({ subredditId, context }) {\n  this._defaultScore = 0;\n  this.View = async (props, { useState, cache, reddit, useInterval, ui }) => {\n   const { items, onClose, footer } = props;\n   const topUsers = await cache(\n    async () => {\n     const topUsers2 = await this.getTopUsers(items);\n     return topUsers2;\n    },\n    {\n     key: \"top-users-leaderboard\",\n     ttl: 1e3\n    }\n   );\n   const [currentUsername] = useState(async () => {\n    const me = await reddit.getCurrentUser();\n    return me.username;\n   });\n   const [isLoading, load] = useState(false);\n   const updateInterval = useInterval(\n    () => {\n     try {\n      if (isLoading) {\n       load(false);\n       updateInterval.stop();\n       onClose();\n      }\n     } catch (e) {\n      console.log(`Error updating leaderboard: ${e}`);\n     }\n    },\n    1e3\n   );\n   const [myScore] = useState(async () => {\n    return await this.getUserScore(currentUsername);\n   });\n   const [inTopUsers] = useState(async () => {\n    if (!topUsers)\n     return null;\n    return topUsers.find((user) => user.member == currentUsername) ?? null;\n   });\n   return /* @__PURE__ */ Devvit.createElement(\"zstack\", { height: \"100%\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageHeight: 788, imageWidth: 512 }), /* @__PURE__ */ Devvit.createElement(\n    \"hstack\",\n    {\n     alignment: \"middle center\",\n     width: \"100%\",\n     height: \"100%\",\n     cornerRadius: \"medium\"\n    },\n    /* @__PURE__ */ Devvit.createElement(\n     \"vstack\",\n     {\n      width: 100,\n      maxWidth: \"512px\",\n      height: \"500px\",\n      alignment: \"center\",\n      padding: \"large\",\n      gap: \"medium\",\n      darkBackgroundColor: \"#131F23\",\n      lightBackgroundColor: \"white\",\n      cornerRadius: \"medium\"\n     },\n     /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"middle\", minHeight: \"40px\" }, /* @__PURE__ */ Devvit.createElement(\n      \"text\",\n      {\n       lightColor: \"black\",\n       darkColor: \"white\",\n       weight: \"bold\",\n       size: \"xlarge\",\n       overflow: \"ellipsis\",\n       grow: true\n      },\n      \"Leaderboard\"\n     ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\n      \"button\",\n      {\n       width: \"40px\",\n       onPress: () => {\n        load(true);\n        updateInterval.start();\n       },\n       icon: \"close-outline\"\n      }\n     )),\n     /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"small\", width: \"100%\" }, !inTopUsers && /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n      LeaderboardRow,\n      {\n       rank: void 0,\n       name: currentUsername,\n       score: myScore,\n       isCurrentUser: true,\n       onPress: () => console.log(\"Navigate to user profile\"),\n       isTopUser: false\n      }\n     ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"1px\", backgroundColor: \"#eaedef\", padding: \"none\", gap: \"none\" })), topUsers.map((user, index) => /* @__PURE__ */ Devvit.createElement(\n      LeaderboardRow,\n      {\n       rank: index + 1,\n       name: user.member,\n       score: user.score,\n       isCurrentUser: user.member == currentUsername,\n       onPress: () => ui.navigateTo(`https://sh.reddit.com/user/${user.member}`),\n       isTopUser: true\n      }\n     ))),\n     footer ?? /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null)\n    )\n   ), isLoading && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"center middle\", width: \"50%\", height: \"50%\", minWidth: \"288px\", minHeight: \"300px\", gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }), /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading...\"))));\n  };\n  this._redis = context.redis;\n  this._id = subredditId;\n }\n static fromSubreddit(props) {\n  return new _Leaderboard(props);\n }\n async addUser(username, score) {\n  if (!username)\n   return;\n  score = score ?? this._defaultScore;\n  const r = await this._redis.zAdd(this.getRankKey(), { member: username, score });\n }\n async getUserScore(username) {\n  try {\n   if (!username)\n    return 0;\n   return await this._redis.zScore(this.getRankKey(), username);\n  } catch (e) {\n   console.log(`Error getting user score: ${e}`);\n   return 0;\n  }\n }\n async incrUserScore(username, incr) {\n  const score = await this.getUserScore(username) ?? this._defaultScore;\n  await this.addUser(username, score + incr);\n }\n // async getUserRank(username : string) : Promise<number> {\n //   return await this._redis.zRank(this.getUserKey(user), username);\n // }\n async getTopUsers(count) {\n  try {\n   return await this._redis.zRange(\n    this.getRankKey(),\n    0,\n    count - 1,\n    {\n     by: \"rank\",\n     reverse: true\n    }\n   );\n  } catch (e) {\n   console.log(`Error getting top users: ${e}`);\n   return [];\n  }\n }\n getRankKey() {\n  return `${this._id}:rank`;\n }\n};\nvar LeaderboardRow = (props) => {\n const { rank: rank2, name, score, onPress, isCurrentUser, isTopUser } = props;\n const isDistinguished = rank2 && rank2 <= 3;\n return /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   backgroundColor: \"#eaedef\",\n   cornerRadius: \"small\",\n   height: \"40px\",\n   width: \"100%\",\n   alignment: \"middle\",\n   onPress,\n   border: \"thin\",\n   borderColor: isCurrentUser ? \"#1E90ff\" : \"#eaedef\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"rgba(0,0,0,0.7)\", selectable: false }, `${rank2 || \" \"}.`),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }),\n  /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    weight: \"bold\",\n    color: \"black\",\n    grow: true,\n    overflow: \"ellipsis\",\n    selectable: false\n   },\n   `${name}${isCurrentUser ? \" (you)\" : \"\"}`\n  ),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"black\", selectable: false }, `${score}`),\n  /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }),\n  isDistinguished && /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n   \"image\",\n   {\n    url: `icon-rank-${rank2}.png`,\n    imageHeight: 256,\n    imageWidth: 256,\n    width: \"24px\",\n    height: \"24px\"\n   }\n  ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }))\n );\n};\n\n// src/components/Quiz.tsx\nvar format = require_format_duration();\nvar Quiz = async ({ navigate, startPage }, context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const reddit = context.reddit;\n const useInterval = context.useInterval;\n const [currentUsername] = useState(async () => {\n  const u = await reddit.getCurrentUser();\n  return u.username;\n });\n const [gameState, setGameState] = useState(\"playing\" /* playing */);\n const [options] = useState(async () => {\n  const keys = [\n   quizKey(\"currentPosition\" /* currentPosition */, postId),\n   quizKey(\"solutionMoves\" /* solutionMoves */, postId),\n   quizKey(\"setUp\" /* setUp */, postId),\n   quizKey(\"title\" /* title */, postId)\n  ];\n  return await redis.mget(keys);\n });\n const [hasPlayed, setHasPlayed] = useState(async () => {\n  let hasPlayed2;\n  try {\n   hasPlayed2 = await redis.get(userKey(userId, postId));\n  } catch {\n  }\n  return hasPlayed2;\n });\n const [showStart, setShowStart] = useState(startPage);\n const [bonus, setBonus] = useState(async () => {\n  if (!hasPlayed)\n   return \"gold\" /* gold */;\n  let bonus2;\n  try {\n   bonus2 = await redis.get(userKey(userId, postId, \"bonus\" /* bonus */));\n   if (!bonus2) {\n    bonus2 = \"undefined\" /* undefined */;\n   } else {\n    bonus2 = bonus2;\n   }\n  } catch {\n   return \"undefined\" /* undefined */;\n  }\n  return bonus2;\n });\n const [startingFen] = useState(options[0] || \"startpos\");\n const [counter, setCounter] = useState(DefaultCounter);\n const [startingSolution] = useState(() => {\n  if (options[1]) {\n   try {\n    return parseSanToTurns(options[1]);\n   } catch (e) {\n    console.error(`Error parsing solution for ${postId}. ${e}`);\n    return [];\n   }\n  } else {\n   return [];\n  }\n });\n const [setUp] = useState(JSON.parse(options[2] || \"false\"));\n const [numMoves] = useState(setUp ? startingSolution.length - 1 : startingSolution.length);\n const [setUpMove] = useState(async () => {\n  const chess2 = new Chess(startingFen);\n  let m = null;\n  if (setUp) {\n   m = chess2.turn() === \"w\" /* white */ ? chess2.move(startingSolution[0].whiteMove) : chess2.move(startingSolution[0].blackMove);\n  }\n  return m;\n });\n var [fen, setFen] = useState(setUpMove?.after || startingFen);\n const chess = new Chess(fen);\n const [solution, setSolution] = useState(() => {\n  if (setUp && chess.turn() === \"w\" /* white */) {\n   return startingSolution.slice(1);\n  } else {\n   return startingSolution;\n  }\n });\n const [turn, setTurn] = useState(chess.turn());\n let [highlights, setHighlights] = useState(() => {\n  if (setUp && setUpMove) {\n   const rc = getRowColFromSquare(setUpMove.to, turn);\n   const toHighlight = {\n    ...rc,\n    type: 3 /* opponentMove */\n   };\n   const rc2 = getRowColFromSquare(setUpMove.from, turn);\n   const fromHighlight = {\n    ...rc2,\n    type: 3 /* opponentMove */\n   };\n   return [toHighlight, fromHighlight];\n  } else {\n   return [];\n  }\n });\n let [showInfo, setShowInfo] = useState(false);\n let [startingHighlights] = useState(highlights);\n let [activeSquare, setActiveSquare] = useState(BlankSquare);\n let [isLoading, load] = useState(false);\n let [showScoreSummary, setShowScoreSummary] = useState(false);\n const updateInterval = useInterval(\n  () => {\n   try {\n    let newCounter = showScoreSummary ? counter + 1e3 : counter - 1e3;\n    if (newCounter <= 0) {\n     if (!hasPlayed) {\n      setBonus(downgradeBonus(bonus));\n     }\n     setCounter(DefaultCounter);\n    } else {\n     setCounter(newCounter);\n    }\n    if (isLoading) {\n     navigate(4 /* LEADERBOARD */);\n     load(false);\n     updateInterval.stop();\n    }\n   } catch (e) {\n    console.log(`Error in Quiz updateInterval call: ${e}`);\n   }\n  },\n  1e3\n );\n startPage && updateInterval.start();\n let moveH = [];\n let moves = [];\n const makeMove = async (move) => {\n  try {\n   let newState = \"playing\" /* playing */;\n   let finalBonus = bonus;\n   let newHasPlayed = hasPlayed;\n   let newShowScoreSummary = showScoreSummary;\n   let newCounter = counter;\n   const activeSide = chess.turn();\n   let m = chess.move(move);\n   fen = chess.fen();\n   const highlights2 = [];\n   if (solution) {\n    const currentTurn = solution[0];\n    const expectedMove = activeSide == \"w\" /* white */ ? currentTurn.whiteMove : currentTurn.blackMove;\n    if (move != expectedMove) {\n     newState = \"lost\" /* lose */;\n     newShowScoreSummary = true;\n     finalBonus = \"fail\" /* fail */;\n     const rc = getRowColFromSquare(m.to, turn);\n     const highlight = {\n      ...rc,\n      type: 5 /* fail */,\n      imgUrl: \"fail.png\"\n     };\n     highlights2.push(highlight);\n     if (!hasPlayed) {\n      await redis.set(userKey(context.userId, context.postId), \"lost\" /* lose */);\n      const puzzleAttempts = quizKey(\"attempts\" /* attempts */, postId);\n      const userAttempts = userStatsKey(context.userId, \"attempts\" /* attempts */);\n      const tx = await redis.watch(puzzleAttempts, userAttempts);\n      tx.multi();\n      tx.incrBy(puzzleAttempts, 1);\n      tx.incrBy(userAttempts, 1);\n      tx.set(userKey(context.userId, context.postId), \"won\" /* win */);\n      await tx.exec();\n      newHasPlayed = \"lost\" /* lose */;\n      newShowScoreSummary = true;\n      newCounter = DefaultCounter;\n     }\n    } else {\n     if (solution.length == 1) {\n      const rc = getRowColFromSquare(m.to, turn);\n      const highlight = {\n       ...rc,\n       type: 4 /* success */\n       // imgUrl: 'win_cropped.gif'\n      };\n      if (!hasPlayed) {\n       const props = {\n        subredditId: context.subredditId,\n        context\n       };\n       const lb = Leaderboard.fromSubreddit(props);\n       const bonusPionts = finalBonus ? BonusValues[finalBonus] : 0;\n       await lb.incrUserScore(currentUsername, DEFAULT_POINTS + bonusPionts);\n       const puzzleSuccesses = quizKey(\"successes\" /* successes */, postId);\n       const userSuccesses = userStatsKey(context.userId, \"successes\" /* successes */);\n       const puzzleAttempts = quizKey(\"attempts\" /* attempts */, postId);\n       const userAttempts = userStatsKey(context.userId, \"attempts\" /* attempts */);\n       const userBonus = userKey(context.userId, postId, \"bonus\" /* bonus */);\n       const tx = await redis.watch(puzzleAttempts, puzzleSuccesses, userAttempts, userSuccesses);\n       tx.multi();\n       tx.incrBy(puzzleAttempts, 1);\n       tx.incrBy(puzzleSuccesses, 1);\n       tx.incrBy(userAttempts, 1);\n       tx.incrBy(userSuccesses, 1);\n       tx.set(userKey(context.userId, context.postId), \"won\" /* win */);\n       tx.set(userBonus, bonus);\n       await tx.exec();\n       newHasPlayed = \"won\" /* win */;\n       newShowScoreSummary = true;\n       newCounter = DefaultCounter;\n      }\n      highlights2.push(highlight);\n      newState = \"won\" /* win */;\n     } else {\n      if (activeSide == \"w\" /* white */) {\n       m = chess.move(solution[0].blackMove);\n       solution.shift();\n      } else {\n       solution.shift();\n       m = chess.move(solution[0].whiteMove);\n      }\n      const oFromRc = getRowColFromSquare(m.from, turn);\n      const oToRc = getRowColFromSquare(m.to, turn);\n      const oFromHighlight = {\n       ...oFromRc,\n       type: 3 /* opponentMove */\n      };\n      const oToHighlight = {\n       ...oToRc,\n       type: 3 /* opponentMove */\n      };\n      highlights2.push(oFromHighlight);\n      highlights2.push(oToHighlight);\n     }\n    }\n   }\n   setFen(chess.fen());\n   setSolution(solution);\n   setHighlights(highlights2);\n   setActiveSquare(BlankSquare);\n   setTurn(activeSide);\n   setGameState(newState);\n   setHasPlayed(newHasPlayed);\n   setBonus(finalBonus);\n   setShowScoreSummary(newShowScoreSummary);\n   setCounter(newCounter);\n  } catch (e) {\n   console.log(`Error caught in makeMove: ${e}`);\n  }\n };\n if (activeSquare && activeSquare !== \" \" /* BLANK */) {\n  const moves2 = chess.moves({ square: activeSquare, verbose: true });\n  moveH = moves2.map((m) => {\n   const rc = getRowColFromSquare(m.to, turn);\n   const h = {\n    ...rc,\n    type: 1 /* move */,\n    san: m.san\n   };\n   return h;\n  });\n }\n const allH = [...highlights, ...moveH];\n return /* @__PURE__ */ Devvit.createElement(\n  \"zstack\",\n  {\n   height: \"100%\",\n   width: \"100%\",\n   alignment: \"center middle\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageWidth: 788, imageHeight: 512 }),\n  /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    gap: \"none\",\n    padding: \"small\",\n    cornerRadius: \"medium\",\n    minWidth: \"288px\",\n    height: \"500px\",\n    alignment: \"center middle\",\n    lightBackgroundColor: \"white\",\n    darkBackgroundColor: \"#131F23\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\", width: \"100%\", height: \"15%\" }, /* @__PURE__ */ Devvit.createElement(QuizHeader, { turn, currentUsername, gameState })),\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", { height: \"65%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: `${(SquareSizeInt + 4) * 8}px`, height: `${(SquareSizeInt + 4) * 8}px`, alignment: \"center middle\", cornerRadius: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n    InteractiveChessBoard,\n    {\n     FEN: fen,\n     highlights: allH,\n     setHighlights,\n     turn,\n     setActiveSquare,\n     makeMove\n    }\n   ))),\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"20%\", width: \"100%\", maxWidth: \"288px\", minWidth: \"288px\", alignment: \"center middle\", cornerRadius: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\n    QuizFooter,\n    {\n     gameState,\n     count: counter,\n     hasPlayed,\n     bonus: bonus ?? \"undefined\" /* undefined */,\n     onInfoPress: () => setShowInfo(true),\n     onStatsPress: () => {\n      load(true);\n     },\n     onRetryPress: async () => {\n      const resetFen = setUpMove?.after || startingFen;\n      const c = new Chess(resetFen);\n      setFen(resetFen);\n      setSolution(setUp && c.turn() === \"w\" /* white */ ? startingSolution.slice(1) : startingSolution);\n      setHighlights(startingHighlights);\n      setActiveSquare(BlankSquare);\n      setTurn(c.turn());\n      setCounter(0);\n      setGameState(\"playing\" /* playing */);\n      navigate(2 /* ACTIVE */);\n     }\n    }\n   ))\n  ),\n  isLoading && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"center middle\", width: \"50%\", height: \"50%\", minWidth: \"288px\", minHeight: \"300px\", gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }), /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading leaderboard \\u{1F3C6}...\"))),\n  showInfo && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { lightBackgroundColor: \"white\", darkBackgroundColor: \"#131F23\", cornerRadius: \"medium\", alignment: \"start top\", width: \"90%\", height: \"90%\", gap: \"large\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"start middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    weight: \"bold\",\n    size: \"xlarge\",\n    overflow: \"ellipsis\",\n    grow: true\n   },\n   \"Quiz Info\"\n  ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n    width: \"40px\",\n    onPress: () => {\n     setShowInfo(false);\n    },\n    icon: \"close-outline\"\n   }\n  )), /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", alignment: \"start\" }, \"Fen\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"small\", wrap: true }, fen)))),\n  showStart && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { darkBackgroundColor: \"#131F23\", lightBackgroundColor: \"white\", cornerRadius: \"medium\", alignment: \"center top\", width: \"50%\", minWidth: \"288px\", height: \"90%\", gap: \"large\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"center middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    color: \"#FF4500\",\n    weight: \"bold\",\n    size: \"xlarge\",\n    wrap: true\n   },\n   \"Solve the chess puzzle!\"\n  )), /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\", gap: \"medium\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"Goal:\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"large\", wrap: true }, options[3] ?? `Complete in ${numMoves} move${numMoves > 1 ? \"s\" : \"\"}`)), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"You are playing\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", size: \"large\" }, turn == \"w\" /* white */ ? \"White\" : \"Black\"), /* @__PURE__ */ Devvit.createElement(\"image\", { url: turn == \"w\" /* white */ ? \"wP.png\" : \"p.png\", imageHeight: 30, imageWidth: 30 }))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"small\", alignment: \"start middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\", alignment: \"start\" }, \"Number of moves:\"), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start\", wrap: true }, numMoves))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", size: \"large\", minWidth: \"100px\", onPress: () => {\n   setShowStart(false);\n   updateInterval.start();\n  } }, \"Start\")))),\n  showScoreSummary && counter >= DefaultCounter + 2e3 && /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", alignment: \"center middle\", backgroundColor: \"rgba(0,0,0,0.6)\" }, /* @__PURE__ */ Devvit.createElement(\n   \"vstack\",\n   {\n    darkBackgroundColor: \"#131F23\",\n    lightBackgroundColor: \"white\",\n    cornerRadius: \"medium\",\n    alignment: \"start top\",\n    minWidth: \"288px\",\n    maxWidth: \"300px\",\n    width: \"90%\",\n    height: \"90%\",\n    gap: \"large\",\n    padding: \"medium\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", alignment: \"start middle\", minHeight: \"40px\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\n    \"text\",\n    {\n     weight: \"bold\",\n     size: \"xlarge\",\n     overflow: \"ellipsis\",\n     color: \"#FF4500\",\n     grow: true\n    },\n    \"Score summary\"\n   ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" })),\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"start top\", padding: \"small\", border: \"thin\", cornerRadius: \"medium\", width: \"100%\", gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", weight: \"bold\", size: \"large\", grow: true }, \"Completion:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\" }, \"+\", gameState == \"won\" /* win */ ? 1 : 0)), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", size: \"large\", weight: \"bold\", grow: true }, \"Time bonus:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\" }, \"+\", BonusValues[bonus ?? \"none\" /* none */])), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"1px\", backgroundColor: \"#eaedef\", padding: \"none\", gap: \"none\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"start middle\", size: \"large\", weight: \"bold\", grow: true }, \"Total:\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\"text\", { alignment: \"end middle\", size: \"large\", weight: \"bold\" }, BonusValues[bonus ?? \"none\" /* none */] + (gameState == \"won\" /* win */ ? 1 : 0)))),\n   /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"large\", grow: true }),\n   /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", size: \"large\", minWidth: \"100px\", onPress: () => {\n    setShowScoreSummary(false);\n    updateInterval.stop();\n   } }, \"OK\"))\n  ))\n );\n};\nvar QuizHeader = (props) => {\n const { turn, currentUsername, gameState } = props;\n let statusText, statusColor, sideColor, sideOppositeColor, sideText;\n switch (gameState) {\n  case \"playing\" /* playing */:\n   statusText = \"Playing\";\n   statusColor = \"#55BD46\";\n   break;\n  case \"won\" /* win */:\n   statusText = \"Success!\";\n   statusColor = \"#55BD46\";\n   break;\n  case \"lost\" /* lose */:\n   statusText = \"Fail!\";\n   statusColor = \"#FF4500\";\n   break;\n }\n sideText = turn == \"w\" /* white */ ? \"White\" : \"Black\";\n sideColor = turn == \"w\" /* white */ ? \"white\" : \"black\";\n sideOppositeColor = turn == \"w\" /* white */ ? \"black\" : \"white\";\n return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"start middle\", grow: true }, /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   padding: \"small\",\n   backgroundColor: sideColor,\n   border: \"thin\",\n   cornerRadius: \"full\",\n   alignment: \"center middle\",\n   minWidth: \"60px\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\n   \"text\",\n   {\n    size: \"large\",\n    weight: \"bold\",\n    color: sideOppositeColor\n   },\n   sideText\n  )\n ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"xsmall\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"small\" }, \"to move\"))), /* @__PURE__ */ Devvit.createElement(\"vstack\", { padding: \"none\", alignment: \"end middle\", minWidth: \"50%\" }, /* @__PURE__ */ Devvit.createElement(\n  \"hstack\",\n  {\n   padding: \"small\",\n   backgroundColor: statusColor,\n   cornerRadius: \"full\",\n   alignment: \"center middle\",\n   minWidth: \"60px\"\n  },\n  /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"large\", color: \"white\" }, statusText)\n ), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"xsmall\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"small\", overflow: \"ellipsis\" }, currentUsername ?? \"You\"))));\n};\nvar QuizFooter = (props) => {\n const { gameState, count, hasPlayed, bonus, onInfoPress, onRetryPress, onStatsPress } = props;\n const lostBonus = !hasPlayed && bonus === \"none\" /* none */;\n let displayBonus = lostBonus ? \"undefined\" /* undefined */ : bonus;\n switch (gameState) {\n  case \"playing\" /* playing */:\n   return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"20%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"plain\", icon: \"info\", size: \"large\", onPress: onInfoPress }), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, \"Info\")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"60%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { minHeight: \"50px\", alignment: \"center middle\" }, !hasPlayed ? count && !lostBonus ? /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, format(count)) : count && lostBonus ? /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"Bonus lost\") : /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"0:00\") : /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, \"Completed\")), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, hasPlayed ? \"Status\" : \"Bonus timer\")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"20%\", height: \"100%\", alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { alignment: \"center middle\", minHeight: \"50px\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xlarge\", weight: \"bold\", alignment: \"center middle\" }, hasPlayed && hasPlayed == \"lost\" /* lose */ ? \"Fail\" : `+${BonusValues[displayBonus ?? \"undefined\" /* undefined */] + 1}`), \" :\"), /* @__PURE__ */ Devvit.createElement(\"text\", { size: \"xsmall\", alignment: \"center middle\" }, hasPlayed ? \"Result\" : \"Bonus\")));\n  case \"won\" /* win */:\n  case \"lost\" /* lose */:\n   return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\n    \"button\",\n    {\n     appearance: \"secondary\",\n     icon: \"refresh\",\n     size: \"medium\",\n     onPress: onRetryPress\n    },\n    \"Retry\"\n   ), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"large\" }), /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"primary\", onPress: onStatsPress, icon: \"contest\", size: \"medium\" }, \"Stats\"), \");\");\n }\n};\n\n// src/components/QuizStats.tsx\nvar QuizStats = async (props, context) => {\n const { redis, cache, userId, postId } = context;\n const data = await cache(async () => {\n  const quizAttempts2 = quizKey(\"attempts\" /* attempts */, postId);\n  const quizSuccesses2 = quizKey(\"successes\" /* successes */, postId);\n  const userAttempts2 = userStatsKey(userId, \"attempts\" /* attempts */);\n  const userSuccesses2 = userStatsKey(userId, \"successes\" /* successes */);\n  const hasPlayed2 = userKey(userId, postId);\n  const data2 = await redis.mget([quizAttempts2, quizSuccesses2, userAttempts2, userSuccesses2, hasPlayed2]);\n  return data2;\n }, {\n  key: \"quiz-stats\",\n  ttl: 1e3\n });\n const quizAttempts = parseInt(data[0] ?? \"0\");\n const quizSuccesses = parseInt(data[1] ?? \"0\");\n const userAttempts = parseInt(data[2] ?? \"0\");\n const userSuccesses = parseInt(data[3] ?? \"0\");\n const userSuccessRate = userAttempts === 0 ? 0 : Math.round(userSuccesses / userAttempts * 100);\n const quizSuccessRate = quizAttempts === 0 ? 0 : Math.round(quizSuccesses / quizAttempts * 100);\n const hasPlayed = data[4] ? data[4] : \"have not attempted this quiz\";\n return /* @__PURE__ */ Devvit.createElement(Devvit.Fragment, null, /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", border: \"thin\", cornerRadius: \"medium\", padding: \"small\" }, /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"50%\", alignment: \"start top\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\" }, \"This Quiz\"), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Attempts: \", quizAttempts), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"% success: \", quizSuccessRate), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"You \", hasPlayed, \" \")), /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"50%\", alignment: \"start top\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"large\" }, \"My stats\"), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Attempts: \", userAttempts), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"% success: \", userSuccessRate, \"%\"))));\n};\n\n// src/main.tsx\nDevvit.configure({\n redditAPI: true,\n // context.reddit will now be available\n redis: true\n});\nvar quizCreationForm = Devvit.createForm(\n (data) => {\n  return {\n   title: \"New chess quiz\",\n   acceptLabel: \"Post\",\n   fields: [\n    {\n     name: \"title\",\n     label: \"Post title\",\n     type: \"string\",\n     helpText: 'State the goal of the quiz in the title. E.g. \"Mate in 3\"',\n     defaultValue: data?.title,\n     required: true\n    },\n    // { \n    //  name: 'pgn', \n    //  label: 'Quiz details (PGN)', \n    //  defaultValue: data?.pgn,\n    //  helpText: \"Quiz details in PGN. First move is the lastMove's most recent move with remaining moves describing the solution.\",\n    //  required: true,\n    //  type: 'paragraph',\n    // },\n    {\n     name: \"position\",\n     label: \"Starting position (FEN)\",\n     defaultValue: data?.position,\n     helpText: \"The starting position of the quiz in FEN format.\",\n     type: \"string\",\n     required: true\n    },\n    // { \n    //  name: 'lastMove', \n    //  label: \"Opponent's Last move (SAN)\", \n    //  defaultValue: data?.lastMove,\n    //  helpText: \"The last move made by the opponent (optional)\",\n    //  type: 'string', \n    //  required: false,\n    // },\n    {\n     name: \"solution\",\n     label: \"Solution (SAN)\",\n     defaultValue: data?.solution,\n     helpText: \"The solution to the quiz in SAN format. E.g. 1. e4 e5 2. Nf3 Nc6 3. Bb5\",\n     type: \"string\",\n     required: true\n    },\n    {\n     // toggle setUp to true if the first move in the solution is the opponent's last move\n     name: \"setUp\",\n     label: \"Set up?\",\n     defaultValue: data?.setUp,\n     helpText: \"Check if the first move in the solution is the opponent's last move\",\n     type: \"boolean\",\n     required: true\n    }\n   ]\n  };\n },\n quizCreationHandler\n);\nasync function quizCreationHandler(event, context) {\n const title = event.values.title;\n const position = event.values.position;\n const solution = event.values.solution;\n const setUp = event.values.setUp;\n const reddit = context.reddit;\n const ui = context.ui;\n let currentPosition;\n try {\n  const chess = new Chess(position);\n } catch (e) {\n  ui.showToast(`Quiz creation failed: check inputs. ${e.toString()}`);\n  ui.showForm(quizCreationForm, event.values);\n  return;\n }\n const subreddit = await reddit.getCurrentSubreddit();\n const post = await reddit.submitPost({\n  // This will show while your custom post is loading\n  preview: /* @__PURE__ */ Devvit.createElement(\n   \"zstack\",\n   {\n    height: \"100%\",\n    width: \"100%\",\n    alignment: \"center middle\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"check_bg_pawn.png\", resizeMode: \"cover\", width: \"100%\", height: \"100%\", imageWidth: 788, imageHeight: 512 }),\n   /* @__PURE__ */ Devvit.createElement(\n    \"vstack\",\n    {\n     gap: \"large\",\n     alignment: \"center middle\",\n     padding: \"medium\",\n     cornerRadius: \"medium\",\n     minWidth: \"288px\",\n     height: \"500px\",\n     darkBackgroundColor: \"#131F23\",\n     lightBackgroundColor: \"white\"\n    },\n    /* @__PURE__ */ Devvit.createElement(\"image\", { url: \"loading.gif\", imageHeight: 50, imageWidth: 50 }),\n    /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\", size: \"xlarge\", color: \"#FF4500\" }, \"Loading chess quiz...\")\n   )\n  ),\n  title,\n  subredditName: subreddit.name\n });\n const kv = {\n  [quizKey(\"currentPosition\" /* currentPosition */, post.id)]: position,\n  [quizKey(\"solutionMoves\" /* solutionMoves */, post.id)]: solution,\n  [quizKey(\"setUp\" /* setUp */, post.id)]: JSON.stringify(setUp),\n  [quizKey(\"title\" /* title */, post.id)]: title\n };\n await context.redis.mset(kv);\n context.ui.showToast({\n  text: `Chess quiz created!`,\n  appearance: \"success\"\n });\n}\nDevvit.addMenuItem({\n label: \"New chess quiz\",\n location: \"subreddit\",\n onPress: async (_event, context) => {\n  context.ui.showForm(quizCreationForm);\n }\n});\nvar App = async (context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const useInterval = context.useInterval;\n const [page, navigate] = useState(2 /* ACTIVE */);\n switch (page) {\n  case 4 /* LEADERBOARD */:\n   const props = {\n    subredditId: context.subredditId,\n    context\n   };\n   const lb = Leaderboard.fromSubreddit(props);\n   return /* @__PURE__ */ Devvit.createElement(\n    lb.View,\n    {\n     items: 5,\n     onClose: () => {\n      navigate(2 /* ACTIVE */);\n     },\n     footer: /* @__PURE__ */ Devvit.createElement(QuizStats, null)\n    }\n   );\n  case 2 /* ACTIVE */:\n  default:\n   return /* @__PURE__ */ Devvit.createElement(Quiz, { navigate, startPage: true });\n }\n};\nDevvit.addCustomPostType({\n height: \"tall\",\n name: \"Community Chess\",\n render: App\n});\nvar main_default = Devvit;\n\n\nFinally here is an example that implements a survey or poll app. This also has examples of multiple screens, reusable components as well as how to use the redis-like backend for storing data.\n\n// src/PollHelpers.tsx\nvar import_numbro = __toESM(require_numbro_min(), 1);\nvar numbro = import_numbro.default;\nvar formatCount = (count) => {\n return numbro(count).format({\n   average: true,\n   mantissa: 1,\n   optionalMantissa: true,\n   trimMantissa: true,\n   thousandSeparated: true\n });\n};\nfunction shuffle(arr) {\n for (let i = arr.length - 1; i > 0; i--) {\n   const j = Math.floor(Math.random() * (i + 1));\n   const temp = arr[i];\n   arr[i] = arr[j];\n   arr[j] = temp;\n }\n}\nvar undefinedValue = `undefined`;\nvar userKey = (userId, postId) => {\n return `polls:${postId ?? undefinedValue}:${userId ?? undefinedValue}`;\n};\nvar key = (keyType, postId) => {\n return `polls:${postId ?? undefinedValue}:${keyType}`;\n};\nvar resetRedis = async (context) => {\n const redis = context.redis;\n await redis.mset({\n   \"polls:undefined:question\": \"What is your favorite color?\",\n   \"polls:undefined:finish\": (/* @__PURE__ */ new Date()).getTime() + 5 * 60 * 1e3 + \"\",\n   \"polls:undefined:0\": \"0\",\n   \"polls:undefined:1\": \"0\",\n   \"polls:undefined:2\": \"0\"\n });\n const voteds = await redis.zRange(`polls:undefined:voted`, 0, -1);\n if (voteds.length > 0) {\n   await redis.del(...voteds.map((voted) => voted.member));\n }\n await redis.del(`polls:undefined:voted`);\n await redis.zAdd(\n   `polls:undefined:options`,\n   {\n     member: \"Red\",\n     score: 0\n   },\n   {\n     member: \"Green\",\n     score: 1\n   },\n   {\n     member: \"Blue\",\n     score: 2\n   }\n );\n console.log(\"I reset the state\");\n};\n\n// src/components/VotePage.tsx\nvar import_moment = __toESM(require_moment(), 1);\nvar PollOption = ({\n option,\n index,\n selectedOption,\n setSelectedOption\n}) => {\n const selectOption = () => setSelectedOption(index);\n const selected = index === selectedOption;\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }), /* @__PURE__ */ Devvit.createElement(\n   \"hstack\",\n   {\n     width: \"100%\",\n     alignment: \"start middle\",\n     onPress: selectOption,\n     gap: \"small\",\n     \"data-selection\": index\n   },\n   /* @__PURE__ */ Devvit.createElement(\"icon\", { name: selected ? \"radio-button-fill\" : \"radio-button-outline\" }),\n   /* @__PURE__ */ Devvit.createElement(\"text\", { grow: true }, option)\n ));\n};\nvar VotePage = async ({\n options,\n shuffledOptions,\n votes,\n setVotes,\n navigate,\n optionsPerPollPage,\n pollPages,\n remainingMillis,\n allowShowResults,\n randomizeOrder\n}, { redis, useState, userId, postId }) => {\n const remaining = import_moment.default.duration(remainingMillis).humanize();\n const [selectedOption, setSelectedOption] = useState(-1);\n const presentedOptions = randomizeOrder ? shuffledOptions : options;\n const submitVote = async () => {\n   const user = userKey(userId, postId);\n   const tx = await redis.watch(user);\n   const selectedOptionString = presentedOptions[selectedOption];\n   const optionIndex = options.indexOf(selectedOptionString);\n   let already = false;\n   try {\n     already = !!await redis.get(user);\n   } catch {\n   }\n   await tx.multi();\n   await tx.zAdd(key(\"voted\" /* voted */, postId), { member: user, score: 0 });\n   if (already) {\n     await tx.exec();\n   } else {\n     await tx.set(user, optionIndex + \"\");\n     await redis.incrBy(`polls:${postId}:${optionIndex}`, 1);\n     await tx.exec();\n     setVotes(votes.map((v, i) => i === optionIndex ? v + 1 : v));\n   }\n   navigate(1 /* RESULTS */);\n };\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n const prevPollPage = async () => {\n   if (pollPage > 1) {\n     setPollPage(pollPage - 1);\n   }\n };\n const nextPollPage = async () => {\n   if (pollPage < pollPages) {\n     setPollPage(pollPage + 1);\n   }\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { height: \"100%\", width: \"100%\", padding: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", color: \"green\" }, \"Open\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", remaining, \" left\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), allowShowResults && /* @__PURE__ */ Devvit.createElement(\"button\", { appearance: \"plain\", onPress: () => navigate(2 /* CONFIRM */) }, \"View Results\")), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { grow: true }, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"small\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"medium\" }, presentedOptions.slice(rangeStart, rangeEnd).map((option, index) => {\n   const props = {\n     option,\n     index: index + rangeStart,\n     selectedOption,\n     setSelectedOption\n   };\n   return /* @__PURE__ */ Devvit.createElement(PollOption, { ...props });\n }))), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"15%\", alignment: \"middle\" }, pollPages > 1 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, gap: \"medium\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"back-outline\",\n     onPress: prevPollPage,\n     disabled: pollPage === 1\n   }\n ), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Page \", pollPage, \" of \", pollPages), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"forward-outline\",\n     onPress: nextPollPage,\n     disabled: pollPage === pollPages\n   }\n )), /* @__PURE__ */ Devvit.createElement(\"spacer\", { grow: true }), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"medium\",\n     appearance: \"primary\",\n     onPress: submitVote,\n     disabled: selectedOption === -1\n   },\n   \"Vote!\"\n )));\n};\n\n// src/components/ResultsPage.tsx\nvar import_moment2 = __toESM(require_moment(), 1);\nvar PollResult = ({ option, votes, total, winner }) => {\n const percent = Math.max(votes / total * 100, 0.2);\n const nice = formatCount(votes);\n const PercentBar = () => percent >= 0 && /* @__PURE__ */ Devvit.createElement(\n   \"hstack\",\n   {\n     cornerRadius: \"small\",\n     backgroundColor: winner ? \"upvote-background-disabled\" : \"downvote-background-disabled\",\n     width: percent,\n     height: \"100%\",\n     alignment: \"center middle\"\n   },\n   /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"spacer\", { shape: \"square\", size: \"small\" }))\n );\n if (!option && !votes) {\n   return /* @__PURE__ */ Devvit.createElement(\"vstack\", null, /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"transparent\" }, \"_\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\", borderColor: \"transparent\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { color: \"transparent\" }, \"_\")));\n }\n return /* @__PURE__ */ Devvit.createElement(\"zstack\", { width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(PercentBar, null), /* @__PURE__ */ Devvit.createElement(\"hstack\", { padding: \"small\", width: \"100%\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { weight: \"bold\" }, nice), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\"text\", { grow: true }, option)));\n};\nvar ResultsPage = async ({\n reset,\n finish,\n setFinish,\n options,\n optionsPerPollPage,\n pollPages,\n votes,\n total,\n remainingMillis,\n navigate\n}, { postId, useState }) => {\n const remaining = import_moment2.default.duration(remainingMillis).humanize();\n const max = Math.max(...votes);\n const zipped = options.map((option, index) => ({\n   option,\n   votes: votes[index],\n   total,\n   winner: votes[index] === max\n }));\n zipped.sort((a, b) => b.votes - a.votes);\n const three = 3 * 60 * 1e3;\n const [pollPage, setPollPage] = useState(1);\n const rangeStart = (pollPage - 1) * optionsPerPollPage;\n const rangeEnd = pollPage * optionsPerPollPage;\n const prevPollPage = async () => {\n   if (pollPage > 1) {\n     setPollPage(pollPage - 1);\n   }\n };\n const nextPollPage = async () => {\n   if (pollPage < pollPages) {\n     setPollPage(pollPage + 1);\n   }\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { width: \"100%\", height: \"100%\", padding: \"medium\" }, remainingMillis > 0 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\", color: \"green\" }, \"Open\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", remaining, \" left\")), remainingMillis <= 0 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { height: \"15%\", width: \"100%\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\" }, \"Closed\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"\\xA0\\xB7 \", formatCount(total), \" votes\")), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { border: \"thin\" }), /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"small\", grow: true }, /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"xsmall\" }), zipped.slice(rangeStart, rangeEnd).map((props) => {\n   return /* @__PURE__ */ Devvit.createElement(PollResult, { ...props });\n })), /* @__PURE__ */ Devvit.createElement(\"hstack\", { width: \"100%\", height: \"15%\", alignment: \"middle\" }, pollPages > 1 && /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, gap: \"medium\", alignment: \"middle\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"back-outline\",\n     onPress: prevPollPage,\n     disabled: pollPage === 1\n   }\n ), /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Page \", pollPage, \" of \", pollPages), /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     size: \"small\",\n     icon: \"forward-outline\",\n     onPress: nextPollPage,\n     disabled: pollPage === pollPages\n   }\n ))), !postId && // i.e. only in development mode.\n /* @__PURE__ */ Devvit.createElement(\"vstack\", { gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Local debug panel\"), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"medium\" }, /* @__PURE__ */ Devvit.createElement(\n   \"button\",\n   {\n     onPress: async () => {\n       await reset();\n       navigate(0 /* VOTE */);\n     }\n   },\n   \"Reset\"\n ), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => navigate(0 /* VOTE */) }, \"Vote again\"), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => setFinish(finish + three) }, \"+3 minutes\"), /* @__PURE__ */ Devvit.createElement(\"button\", { onPress: () => setFinish(finish - three) }, \"-3 minutes\"))));\n};\n\n// src/components/CreatePoll.tsx\nvar addPoll = Devvit.createForm(\n {\n   title: \"Add a poll\",\n   acceptLabel: \"Post\",\n   fields: [\n     {\n       name: \"question\",\n       label: \"Question\",\n       type: \"string\",\n       required: true,\n       helpText: `E.g. What is your favorite color?`\n     },\n     // Description will be used as post selftext, once that is supported for custom posts\n     // {\n     //   name: `description`,\n     //   label: `Description (Optional)`,\n     //   type: `string`,\n     // },\n     {\n       name: \"answers\",\n       label: \"Answers (up to 12 total, use a comma to separate)\",\n       type: \"paragraph\",\n       required: true,\n       helpText: `E.g. \"Red, Orange, Blue, Mother of Pearl\"`\n     },\n     {\n       name: \"days\",\n       label: \"Days to allow voting\",\n       type: \"string\",\n       defaultValue: `2`,\n       required: true\n     },\n     {\n       name: \"randomizeOrder\",\n       label: \"Shuffle order of poll options\",\n       type: \"boolean\",\n       defaultValue: true,\n       helpText: `To reduce bias, options will be presented to the user in a shuffled order.`\n     },\n     {\n       name: \"allowShowResults\",\n       label: 'Include \"Show Results\" option',\n       type: \"boolean\",\n       defaultValue: true,\n       helpText: `This allow users to see poll results without voting. Users cannot vote after viewing the results.`\n     }\n   ]\n },\n async (event, { reddit, subredditId, ui, redis }) => {\n   const sub = await reddit.getSubredditById(subredditId);\n   const answers = event.values.answers.split(\",\").filter((answer) => answer.trim() !== \"\").slice(0, 12).map((answer, i) => ({ member: answer.trim(), score: i }));\n   if (answers.length < 2) {\n     ui.showToast({\n       text: \"Post Failed - You must include at least 2 poll options.\",\n       appearance: \"neutral\"\n     });\n     return;\n   }\n   const options = {\n     subredditName: sub.name,\n     title: event.values.question,\n     // text: \"TODO - description/selftext\",\n     preview: /* @__PURE__ */ Devvit.createElement(\"hstack\", { alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Loading...\"))\n   };\n   const post = await reddit.submitPost(options);\n   const timestamp = (/* @__PURE__ */ new Date()).getTime() + parseInt(event.values.days) * 24 * 60 * 60 * 1e3;\n   const allowShowResults = event.values.allowShowResults ? \"true\" : \"false\";\n   const randomizeOrder = event.values.randomizeOrder ? \"true\" : \"false\";\n   await redis.set(key(\"finish\" /* finish */, post.id), timestamp + \"\");\n   await redis.set(key(\"question\" /* question */, post.id), event.values.question);\n   await redis.set(key(\"description\" /* description */, post.id), event.values.description);\n   await redis.zAdd(key(\"options\" /* options */, post.id), ...answers);\n   await redis.set(key(\"allowShowResults\" /* allowShowResults */, post.id), allowShowResults);\n   await redis.set(key(\"randomizeOrder\" /* randomizeOrder */, post.id), randomizeOrder);\n   ui.showToast(\"Poll created!\");\n }\n);\n\n// src/components/ConfirmPage.tsx\nvar ConfirmPage = async ({ votes, setVotes, navigate }, { redis, userId, postId }) => {\n const skipOption = -2;\n const skipVote = async () => {\n   const user = userKey(userId, postId);\n   const tx = await redis.watch(user);\n   let already = false;\n   try {\n     already = !!await redis.get(user);\n   } catch {\n   }\n   await tx.multi();\n   await tx.zAdd(key(\"voted\" /* voted */, postId), { member: user, score: 0 });\n   if (already) {\n     await tx.exec();\n   } else {\n     await tx.set(user, skipOption + \"\");\n     await redis.incrBy(`polls:${postId}:${skipOption}`, 1);\n     await tx.exec();\n     setVotes(votes.map((v, i) => i === skipOption ? v + 1 : v));\n   }\n   navigate(1 /* RESULTS */);\n };\n return /* @__PURE__ */ Devvit.createElement(\"vstack\", { grow: true, alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"heading\" }, \"Are you sure?\"), /* @__PURE__ */ Devvit.createElement(\"text\", { style: \"body\" }, \"You will not be able to vote after viewing the results.\"), /* @__PURE__ */ Devvit.createElement(\"spacer\", { size: \"medium\" }), /* @__PURE__ */ Devvit.createElement(\"hstack\", { gap: \"large\" }, /* @__PURE__ */ Devvit.createElement(\"button\", { size: \"large\", appearance: \"secondary\", onPress: () => navigate(0 /* VOTE */) }, \"Go back to vote\"), /* @__PURE__ */ Devvit.createElement(\"button\", { size: \"large\", appearance: \"destructive\", onPress: () => skipVote() }, \"Show me the results!\")));\n};\n\n// src/main.tsx\nDevvit.configure({\n redis: true,\n redditAPI: true\n});\nvar App = async (context) => {\n const useState = context.useState;\n const redis = context.redis;\n const postId = context.postId;\n const userId = context.userId;\n const [page, navigate] = useState(async () => {\n   let hasVoted = false;\n   try {\n     hasVoted = !!await redis.get(userKey(userId, postId));\n   } catch {\n   }\n   return hasVoted ? 1 /* RESULTS */ : 0 /* VOTE */;\n });\n useState(async () => {\n   if (postId)\n     return;\n   if (!await redis.get(key(\"question\" /* question */, `undefined`))) {\n     await resetRedis(context);\n   }\n });\n const [currentUserId] = useState(userId);\n const [options] = useState(async () => {\n   const options2 = await redis.zRange(key(\"options\" /* options */, postId), 0, -1);\n   return options2.map((option) => option.member);\n });\n const [shuffledOptions] = useState(async () => {\n   const array = [...options];\n   shuffle(array);\n   return array;\n });\n const [votes, setVotes] = useState(async () => {\n   const rsp = await redis.mget(options.map((_option, i) => `polls:${postId}:${i}`));\n   return rsp.map((count) => parseInt(count || \"0\"));\n });\n const reset = async () => {\n   await resetRedis(context);\n   setVotes([0, 0, 0]);\n   setFinish((/* @__PURE__ */ new Date()).getTime() + 5 * 60 * 1e3);\n };\n const total = votes.reduce((a, b) => a + b, 0);\n const now = (/* @__PURE__ */ new Date()).getTime();\n const [finish, setFinish] = useState(async () => {\n   const finish2 = await redis.get(key(\"finish\" /* finish */, postId));\n   return parseInt(finish2 || \"0\");\n });\n const remainingMillis = finish - now;\n const [description, _setDescription] = useState(async () => {\n   return await redis.get(key(\"description\" /* description */, postId));\n });\n const [allowShowResults, _setAllowShowResults] = useState(async () => {\n   const allow = await redis.get(key(\"allowShowResults\" /* allowShowResults */, postId));\n   return allow === \"true\";\n });\n const [randomizeOrder, _setRandomizeOrder] = useState(async () => {\n   const randomize = await redis.get(key(\"randomizeOrder\" /* randomizeOrder */, postId));\n   return randomize === \"true\";\n });\n const optionsPerPollPage = 4;\n const pollPages = Math.ceil(options.length / optionsPerPollPage);\n const props = {\n   navigate,\n   options,\n   shuffledOptions,\n   optionsPerPollPage,\n   pollPages,\n   setFinish,\n   votes,\n   description,\n   finish,\n   total,\n   setVotes,\n   remainingMillis,\n   allowShowResults,\n   randomizeOrder,\n   reset\n };\n if (!currentUserId) {\n   return /* @__PURE__ */ Devvit.createElement(\"hstack\", { grow: true, alignment: \"center middle\" }, /* @__PURE__ */ Devvit.createElement(\"text\", null, \"Not logged in\"));\n } else if (page === 0 /* VOTE */ && remainingMillis > 0) {\n   return /* @__PURE__ */ Devvit.createElement(VotePage, { ...props });\n } else if (page === 2 /* CONFIRM */ && remainingMillis > 0) {\n   return /* @__PURE__ */ Devvit.createElement(ConfirmPage, { ...props });\n } else {\n   return /* @__PURE__ */ Devvit.createElement(ResultsPage, { ...props });\n }\n};\nDevvit.addMenuItem({\n label: \"Create a new poll\",\n location: \"subreddit\",\n onPress: (_event, context) => {\n   context.ui.showForm(addPoll);\n }\n});\nDevvit.addCustomPostType({\n name: \"Polls Plus\",\n description: \"Polls but better\",\n render: App\n});\nvar main_default = Devvit;\n\n\none more thing: here is an example of how JSX syntax can be used instead of calls like Devvit.createElement. This example creates a progress bar with two buttons to increase and decrease the progress a users sees on screen. Where possible, JSX should be used instead of Devvit.createElement.\n\nimport {Devvit} from '@devvit/public-api'\n\nDevvit.addCustomPostType({\n name: 'Progress bar example',\n render: context => {\n  const [progress, setProgress] = context.useState(30)\n  return (\n   <vstack\n    alignment='center middle'\n    height='100%'\n    gap='medium'\n    padding='large'\n   >\n    <vstack backgroundColor='#FFD5C6' cornerRadius='full' width='100%'>\n     <hstack backgroundColor='#D93A00' width={`${progress}%`}>\n      <spacer size='medium' shape='square' />\n     </hstack>\n    </vstack>\n    <hstack gap='medium' width='100%'>\n     <button\n      icon='subtract-fill'\n      width='50%'\n      onPress={() => setProgress(progress => Math.max(progress - 10, 0))}\n     />\n     <button\n      icon='add-fill'\n      width='50%'\n      onPress={() =>\n       setProgress(progress => Math.min(progress + 10, 100))\n      }\n     />\n    </hstack>\n   </vstack>\n  )\n }\n})\n\nexport default Devvit"},
  ];